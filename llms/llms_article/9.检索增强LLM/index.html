<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>检索增强LLM | 37.2° Blog</title><meta name="author" content="Firefly"><meta name="copyright" content="Firefly"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文章来源：万字长文: 检索增强 LLM (qq.com)  ChatGPT 的出现，让我们看到了大语言模型 ( Large Language Model, LLM ) 在语言和代码理解、人类指令遵循、基本推理等多方面的能力，但幻觉问题 Hallucinations 仍然是当前大语言模型面临的一个重要挑战。简单来说，幻觉问题是指 LLM 生成不正确、荒谬或者与事实不符的结果。此外，数据新鲜度 (">
<meta property="og:type" content="article">
<meta property="og:title" content="检索增强LLM">
<meta property="og:url" content="https://wdndev.github.io/llms/llms_article/9.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BALLM/index.html">
<meta property="og:site_name" content="37.2° Blog">
<meta property="og:description" content="文章来源：万字长文: 检索增强 LLM (qq.com)  ChatGPT 的出现，让我们看到了大语言模型 ( Large Language Model, LLM ) 在语言和代码理解、人类指令遵循、基本推理等多方面的能力，但幻觉问题 Hallucinations 仍然是当前大语言模型面临的一个重要挑战。简单来说，幻觉问题是指 LLM 生成不正确、荒谬或者与事实不符的结果。此外，数据新鲜度 (">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wdndev.github.io/img/wdn_icon.png">
<meta property="article:published_time" content="2024-01-12T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-01T23:46:10.375Z">
<meta property="article:author" content="Firefly">
<meta property="article:tag" content="Transformer">
<meta property="article:tag" content="LLMs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdndev.github.io/img/wdn_icon.png"><link rel="shortcut icon" href="/img/wdn_icon.png"><link rel="canonical" href="https://wdndev.github.io/llms/llms_article/9.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BALLM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search/.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":100,"languages":{"author":"Author: Firefly","link":"Link: ","source":"Source: 37.2° Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '检索增强LLM',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-02 07:46:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/wdn_icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">565</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Content</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/paper_reading/pr_content"><i class="fa-fw fas fa-newspaper"></i><span> Paper</span></a></li><li><a class="site-page child" href="/llms/llms_idx"><i class="fa-fw fa-regular fa-bookmark"></i><span> LLMs</span></a></li><li><a class="site-page child" href="/jupyter"><i class="fa-fw fa-solid fa-file"></i><span> Jupyter</span></a></li><li><a class="site-page child" href="/dsa/dsa_idx"><i class="fa-fw fas fa-tree"></i><span> Algorithm</span></a></li><li><a class="site-page child" href="/program_language/pl_idx"><i class="fa-fw fas fa-code"></i><span> PLs</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-calendar-days"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/daily/github/index"><i class="fa-fw fas fa-arrow-trend-up"></i><span> Github</span></a></li><li><a class="site-page child" href="/daily/weibo/index"><i class="fa-fw fas fa-brands fa-weibo"></i><span> Weibo</span></a></li><li><a class="site-page child" href="/daily/hf/index"><i class="fa-fw fas fa-face-smile"></i><span> HF</span></a></li><li><a class="site-page child" href="/daily/domain/index"><i class="fa-fw fas fa-book-open"></i><span> Arxiv</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="37.2° Blog"><span class="site-name">37.2° Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Content</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/paper_reading/pr_content"><i class="fa-fw fas fa-newspaper"></i><span> Paper</span></a></li><li><a class="site-page child" href="/llms/llms_idx"><i class="fa-fw fa-regular fa-bookmark"></i><span> LLMs</span></a></li><li><a class="site-page child" href="/jupyter"><i class="fa-fw fa-solid fa-file"></i><span> Jupyter</span></a></li><li><a class="site-page child" href="/dsa/dsa_idx"><i class="fa-fw fas fa-tree"></i><span> Algorithm</span></a></li><li><a class="site-page child" href="/program_language/pl_idx"><i class="fa-fw fas fa-code"></i><span> PLs</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-calendar-days"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/daily/github/index"><i class="fa-fw fas fa-arrow-trend-up"></i><span> Github</span></a></li><li><a class="site-page child" href="/daily/weibo/index"><i class="fa-fw fas fa-brands fa-weibo"></i><span> Weibo</span></a></li><li><a class="site-page child" href="/daily/hf/index"><i class="fa-fw fas fa-face-smile"></i><span> HF</span></a></li><li><a class="site-page child" href="/daily/domain/index"><i class="fa-fw fas fa-book-open"></i><span> Arxiv</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">检索增强LLM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-01-12T16:00:00.000Z" title="Created 2024-01-13 00:00:00">2024-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-01T23:46:10.375Z" title="Updated 2025-11-02 07:46:10">2025-11-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LLMs/">LLMs</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">11.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>35min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="检索增强LLM"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><blockquote>
<p>文章来源：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA5NTQ2MDEyOA==\&amp;mid=2247484380\&amp;idx=1\&amp;sn=7b0b5dc3f76dd7a634ebb77df8697a24\&amp;chksm=90be4d93a7c9c485593b6a299d607bfbcc30f05ec691b85f1fb6cf81c51ffe863dbc34759be6\&amp;mpshare=1\&amp;scene=1\&amp;srcid=1204gaSWi0sA7clI6UZEYYL5\&amp;sharer_shareinfo=f728c72f50e0aee521fb1319eb3b82b0\&amp;sharer_shareinfo_first=f728c72f50e0aee521fb1319eb3b82b0#rd" title="万字长文: 检索增强 LLM (qq.com)">万字长文: 检索增强 LLM (qq.com)</a></p>
</blockquote>
<p>ChatGPT 的出现，让我们看到了大语言模型 ( Large Language Model, LLM ) 在语言和代码理解、人类指令遵循、基本推理等多方面的能力，但幻觉问题 <a target="_blank" rel="noopener" href="https://machinelearningmastery.com/a-gentle-introduction-to-hallucinations-in-large-language-models/" title="Hallucinations"><strong>Hallucinations</strong></a> 仍然是当前大语言模型面临的一个重要挑战。简单来说，<strong>幻觉问题是指 LLM 生成不正确、荒谬或者与事实不符的结果</strong>。此外，<strong>数据新鲜度 ( Data Freshness ) </strong>也是 LLM 在生成结果时出现的另外一个问题，即 LLM 对于一些时效性比较强的问题可能给不出或者给出过时的答案。而通过检索外部相关信息的方式来增强 LLM 的生成结果是当前解决以上问题的一种流行方案，这里把这种方案称为 <strong>检索增强 LLM</strong> ( Retrieval Augmented LLM )，有时候也被称为 检索增强生成 ( Retrieval Augmented Generation, RAG )。&#x20;</p>
<p>这篇长文将对检索增强 LLM 的方案进行一个相对全面的介绍。主要内容包括：</p>
<ul>
<li>检索增强 LLM 的概念介绍、重要性及其解决的问题</li>
<li>检索增强 LLM 的关键模块及其实现方法</li>
<li>检索增强 LLM 的一些案例分析和应用</li>
</ul>
<h1 id="1-RAG基本概念"><a href="#1-RAG基本概念" class="headerlink" title="1.RAG基本概念"></a>1.RAG基本概念</h1><h2 id="1-1-什么是检索增强-LLM"><a href="#1-1-什么是检索增强-LLM" class="headerlink" title="1.1 什么是检索增强 LLM"></a>1.1 什么是检索增强 LLM</h2><p><strong>检索增强 LLM ( Retrieval Augmented LLM )</strong>，简单来说，<strong>就是给 LLM 提供外部数据库，对于用户问题 ( Query )，通过一些信息检索 ( Information Retrieval, IR ) 的技术，先从外部数据库中检索出和用户问题相关的信息，然后让 LLM 结合这些相关信息来生成结果</strong>。下图是一个检索增强 LLM 的简单示意图。</p>
<p><img src="image/lr3r0h6wjf_jKUSOHnlR7.png" alt=""></p>
<p>OpenAI 研究科学家 Andrej Karpathy 前段时间在微软 Build 2023 大会上做过一场关于 GPT 模型现状的分享 <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=bZQun8Y4L2A\&amp;ab_channel=MicrosoftDeveloper" title="State of GPT">State of GPT</a>，这场演讲前半部分分享了 ChatGPT 这类模型是如何一步一步训练的，后半部分主要分享了 LLM 模型的一些应用方向，其中就对检索增强 LLM 这个应用方向做了简单介绍。下面这张图就是 Andrej 分享中关于这个方向的介绍。</p>
<p><img src="image/itxqktryzo_DYwXlmZ3eU.jpeg" alt=""></p>
<p>传统的信息检索工具，比如 Google/Bing 这样的搜索引擎，只有检索能力 ( <strong>Retrieval-only</strong> )，现在 LLM 通过预训练过程，将海量数据和知识嵌入到其巨大的模型参数中，具有记忆能力 ( <strong>Memory-only</strong> )。从这个角度看，检索增强 LLM 处于中间，将 LLM 和传统的信息检索相结合，通过一些信息检索技术将相关信息加载到 LLM 的工作内存 ( <strong>Working Memory</strong> ) 中，即 LLM 的上下文窗口 ( <strong>Context Window</strong> )，亦即 LLM 单次生成时能接受的最大文本输入。</p>
<p>不仅 Andrej 的分享中提到基于检索来增强 LLM 这一应用方式，从一些著名投资机构针对 AI 初创企业技术栈的调研和总结中，也可以看到基于检索来增强 LLM 技术的广泛应用。比如今年6月份红杉资本发布了一篇关于大语言模型技术栈的文章 <a target="_blank" rel="noopener" href="https://www.sequoiacap.com/article/llm-stack-perspective/" title="The New Language Model Stack"><strong>The New Language Model Stack</strong></a>，其中就给出了一份对其投资的33家 AI 初创企业进行的问卷调查结果，下图的调查结果显示有 88% 左右的创业者表示在自己的产品中有使用到基于检索增强 LLM 技术。</p>
<p><img src="image/lnxah_g3hd_xfRJIDvjhU.png" alt=""></p>
<p>无独有偶，美国著名风险投资机构 A16Z 在今年6月份也发表了一篇介绍当前 LLM 应用架构的总结文章 <a target="_blank" rel="noopener" href="https://a16z.com/emerging-architectures-for-llm-applications/" title="Emerging Architectures for LLM Applications"><strong>Emerging Architectures for LLM Applications</strong></a>，下图就是文章中总结的当前 LLM 应用的典型架构，其中最上面 <strong>Contextual Data</strong> 引入 LLM 的方式就是一种通过检索来增强 LLM 的思路。</p>
<p><img src="image/v0f4orzl_h_i1A38f1KVr.png" alt=""></p>
<h2 id="1-2-检索增强-LLM-解决的问题"><a href="#1-2-检索增强-LLM-解决的问题" class="headerlink" title="1.2 检索增强 LLM 解决的问题"></a>1.2 检索增强 LLM 解决的问题</h2><p>为什么要结合传统的信息检索系统来增强 LLM ？换句话说，基于检索增强的 LLM 主要解决的问题是什么？这部分内容参考自普林斯顿大学陈丹琦小组之前在 ACL 2023 大会上关于基于检索的语言模型的分享 ACL 2023 Tutorial: Retrieval-based Language Models and Applications</p>
<h3 id="（1）长尾知识"><a href="#（1）长尾知识" class="headerlink" title="（1）长尾知识"></a>（1）长尾知识</h3><p>虽然当前 LLM 的训练数据量已经非常庞大，动辄几百 GB 级别的数据量，万亿级别的标记数量 ( Token )，比如 GPT-3 的预训练数据使用了3000 亿量级的标记，LLaMA 使用了 1.4 万亿量级的标记。训练数据的来源也十分丰富，比如维基百科、书籍、论坛、代码等，LLM 的模型参数量也十分巨大，从几十亿、百亿到千亿量级，但让 LLM 在有限的参数中记住所有知识或者信息是不现实的，训练数据的涵盖范围也是有限的，总会有一些长尾知识在训练数据中不能覆盖到。</p>
<p><strong>对于一些相对通用和大众的知识，LLM 通常能生成比较准确的结果，而对于一些长尾知识</strong>，LLM 生成的回复通常并不可靠。ICML 会议上的这篇论文 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2211.08411" title="Large Language Models Struggle to Learn Long-Tail Knowledge">Large Language Models Struggle to Learn Long-Tail Knowledge</a>，就研究了 LLM 对基于事实的问答的准确性和预训练数据中相关领域文档数量的关系，发现有很强的相关性，即<strong>预训练数据中相关文档数量越多，LLM 对事实性问答的回复准确性就越高</strong>。从这个研究中可以得出一个简单的结论 ——<strong> LLM 对长尾知识的学习能力比较弱</strong>。下面这张图就是论文中绘制的相关性曲线。</p>
<p><img src="image/vwb__1luhn_yItjsNxrSZ.png" alt=""></p>
<p>为了提升 LLM 对长尾知识的学习能力，容易想到的是<strong>在训练数据加入更多的相关长尾知识，或者增大模型的参数量</strong>，虽然这两种方法确实都有一定的效果，上面提到的论文中也有实验数据支撑，但这<strong>两种方法是不经济的</strong>，即需要一个很大的训练数据量级和模型参数才能大幅度提升 LLM 对长尾知识的回复准确性。而通<strong>过检索的方法把相关信息在 LLM 推断时作为上下文 ( Context ) 给出</strong>，既能达到一个比较好的回复准确性，也是一种<strong>比较经济的方式</strong>。下面这张图就是提供相关信息的情况下，不同大小模型的回复准确性，对比上一张图，可以看到对于同一参数量级的模型，在提供少量相关文档参与预训练的情况下，让模型在推断阶段利用相关信息，其回复准确性有了大幅提升。</p>
<p><img src="image/0_at8gi833_NCahb9PQK7.png" alt=""></p>
<h3 id="（2）私有数据"><a href="#（2）私有数据" class="headerlink" title="（2）私有数据"></a>（2）私有数据</h3><p>ChatGPT 这类通用的 LLM 预训练阶段利用的大部分都是公开的数据，<strong>不包含私有数据，因此对于一些私有领域知识是欠缺的</strong>。比如问 ChatGPT 某个企业内部相关的知识，ChatGPT 大概率是不知道或者胡编乱造。虽然可以在预训练阶段加入私有数据或者利用私有数据进行微调，但训练和迭代成本很高。此外，有研究和实践表明，<strong>通过一些特定的攻击手法，可以让 LLM 泄漏训练数据，如果训练数据中包含一些私有信息，就很可能会发生隐私信息泄露</strong>。比如这篇论文 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/2012.07805" title="Extracting Training Data from Large Language Models">Extracting Training Data from Large Language Models</a> 的研究者们就通过构造的 Query 从 <strong>GPT-2</strong> 模型中提取出了个人公开的姓名、邮箱、电话号码和地址信息等，即使这些信息可能只在训练数据中出现一次。文章还发现，较大规模的模型比较小规模的更容易受到攻击。</p>
<p><img src="image/09jzx3c10e_-l4xmNesLo.png" alt=""></p>
<p><strong>如果把私有数据作为一个外部数据库，让 LLM 在回答基于私有数据的问题时，直接从外部数据库中检索出相关信息，再结合检索出的相关信息进行回答</strong>。这样就不用通过预训练或者微调的方法让 LLM 在参数中记住私有知识，既节省了训练或者微调成本，也一定程度上避免了私有数据的泄露风险。</p>
<h3 id="（3）数据新鲜度"><a href="#（3）数据新鲜度" class="headerlink" title="（3）数据新鲜度"></a>（3）数据新鲜度</h3><p>由于 LLM 中学习的知识来自于训练数据，虽然大部分知识的更新周期不会很快，但依然会有一些知识或者信息更新得很频繁。<strong>LLM 通过从预训练数据中学到的这部分信息就很容易过时</strong>。比如 GPT-4 模型使用的是截止到 2021-09 的预训练数据，因此涉及这个日期之后的事件或者信息，它会拒绝回答或者给出的回复是过时或者不准确的。下面这个示例是问 GPT-4 当前推特的 CEO 是谁，GPT-4 给出的回复还是 Jack Dorsey，并且自己会提醒说回复可能已经过时了。</p>
<p><img src="image/kl782vhbz9_VKUVE7-LA7.png" alt=""></p>
<p>如果<strong>把频繁更新的知识作为外部数据库，供 LLM 在必要的时候进行检索，就可以实现在不重新训练 LLM 的情况下对 LLM 的知识进行更新和拓展，从而解决 LLM 数据新鲜度的问题</strong>。</p>
<h3 id="（4）来源验证和可解释性"><a href="#（4）来源验证和可解释性" class="headerlink" title="（4）来源验证和可解释性"></a>（4）来源验证和可解释性</h3><p>通常情况下，LLM 生成的输出不会给出其来源，比较难解释为什么会这么生成。而<strong>通过给 LLM 提供外部数据源，让其基于检索出的相关信息进行生成，就在生成的结果和信息来源之间建立了关联，因此生成的结果就可以追溯参考来源，可解释性和可控性就大大增强</strong>。即可以知道 LLM 是基于什么相关信息来生成的回复。Bing Chat 就是利用检索来增强 LLM 输出的典型产品，下图展示的就是 Bing Chat 的产品截图，可以看到其生成的回复中会给出相关信息的链接。</p>
<p><img src="image/m010m6_j_w_wOGzQZgDDh.png" alt=""></p>
<p>利用检索来增强 LLM 的输出，其中很重要的一步是通过一些检索相关的技术从外部数据中找出相关信息片段，然后把相关信息片段作为上下文供 LLM 在生成回复时参考。有人可能会说，随着 LLM 的上下文窗口 ( <strong>Context Window</strong> ) 越来越长，检索相关信息的步骤是不是就没有必要了，直接在上下文中提供尽可能多的信息。比如 GPT-4 模型当前接收的最大上下文长度是 32K， Claude 模型最大允许 <a target="_blank" rel="noopener" href="https://www.anthropic.com/index/100k-context-windows" title="100K">100K</a> 的上下文长度。</p>
<p>虽然 LLM 的上下文窗口越来越大，但检索相关信息的步骤仍然是重要且必要的。一方面当前 <strong>LLM 的网络架构决定了其上下文窗口的长度是会有上限的</strong>，不会无限增长。另外看似很大的上下文窗口，能容纳的信息其实比较有限，比如 32K 的长度可能仅仅相当于一篇大学毕业论文的长度。另一方面，有研究表明，<strong>提供少量更相关的信息，相比于提供大量不加过滤的信息，LLM 回复的准确性会更高</strong>。比如斯坦福大学的这篇论文 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2307.03172.pdf" title="Lost in the Middle">Lost in the Middle</a> 就给出了下面的实验结果，可以看到 LLM 回复的准确性随着上下文窗口中提供的文档数量增多而下降。</p>
<p><img src="image/oo62b87hhs_XMk2he42vo.png" alt=""></p>
<p><strong>利用检索技术从大量外部数据中找出与输入问题最相关的信息片段，在为 LLM 生成回复提供参考的同时，也一定程度上过滤掉一些非相关信息的干扰，便于提高生成回复的准确性</strong>。此外，上下文窗口越大，推理成本越高。所以相关信息检索步骤的引入也能降低不必要的推理成本。</p>
<h1 id="2-关键模块"><a href="#2-关键模块" class="headerlink" title="2.关键模块"></a>2.关键模块</h1><p>为了构建检索增强 LLM 系统，需要实现的关键模块和解决的问题包括:</p>
<ul>
<li><strong>数据和索引模块</strong>：如何处理外部数据和构建索引</li>
<li><strong>查询和检索模块</strong>：如何准确高效地检索出相关信息</li>
<li><strong>响应生成模块</strong>：如何利用检索出的相关信息来增强 LLM 的输出</li>
</ul>
<h2 id="2-1-数据和索引模块"><a href="#2-1-数据和索引模块" class="headerlink" title="2.1 数据和索引模块"></a>2.1 数据和索引模块</h2><h3 id="（1）数据获取"><a href="#（1）数据获取" class="headerlink" title="（1）数据获取"></a>（1）数据获取</h3><p>数据获取模块的作用一般是<strong>将多种来源、多种类型和格式的外部数据转换成一个统一的文档对象</strong> ( Document Object )，便于后续流程的处理和使用。文档对象除了包含原始的文本内容，一般还会携带文档的<strong>元信息 ( Metadata )</strong>，<strong>可以用于后期的检索和过滤</strong>。元信息包括但不限于：</p>
<ul>
<li>时间信息，比如文档创建和修改时间</li>
<li>标题、关键词、实体(人物、地点等)、文本类别等信息</li>
<li>文本总结和摘要</li>
</ul>
<p><strong>有些元信息可以直接获取，有些则可以借助 NLP 技术</strong>，比如关键词抽取、实体识别、文本分类、文本摘要等。既可以采用传统的 NLP 模型和框架，也可以基于 LLM 实现。</p>
<p><img src="image/paomc13g0j_Z3yCu2BQdq.png" alt=""></p>
<p>外部数据的来源可能是多种多样的，比如可能来自</p>
<ul>
<li>Google 套件里各种 Doc 文档、Sheet 表格、Slides 演示、Calendar 日程、Drive 文件等</li>
<li>Slack、Discord 等聊天社区的数据</li>
<li>Github、Gitlab 上托管的代码文件</li>
<li>Confluence 上各种文档</li>
<li>Web 网页的数据</li>
<li>API 返回的数据</li>
<li>本地文件</li>
</ul>
<p>外部数据的类型和文件格式也可能是多样化的，比如</p>
<ul>
<li>从数据类型来看，包括纯文本、表格、演示文档、代码等</li>
<li>从文件存储格式来看，包括 txt、csv、pdf、markdown、json 等格式</li>
</ul>
<p>外部数据可能是多语种的，比如中文、英文、德文、日文等。除此之外，还可能是多模态的，除了上面讨论的文本模态，还包括图片、音频、视频等多种模态。不过这篇文章中讨论的外部数据将限定在文本模态。</p>
<p>在构建数据获取模块时，不同来源、类型、格式、语种的数据可能都需要采用不同的读取方式。</p>
<h3 id="（2）文本分块"><a href="#（2）文本分块" class="headerlink" title="（2）文本分块"></a>（2）文本分块</h3><p>文本分块是<strong>将长文本切分成小片段的过程</strong>，比如将一篇长文章切分成一个个相对短的段落。那么为什么要进行文本分块？一方面<strong>当前 LLM 的上下文长度是有限制的</strong>，直接把一篇长文全部作为相关信息放到 LLM 的上下文窗口中，可能会超过长度限制。另一方面，对于长文本来说，即使其和查询的问题相关，但<strong>一般不会通篇都是完全相关的</strong>，而分块能一定程度上剔除不相关的内容，<strong>为后续的回复生成过滤一些不必要的噪声</strong>。</p>
<p><strong>文本分块的好坏将很大程度上影响后续回复生成的效果，切分得不好，内容之间的关联性会被切断。因此设计一个好的分块策略十分重要</strong>。分块策略包括具体的切分方法 ( 比如是按句子切分还是段落切分 )，块的大小设为多少合适，不同的块之间是否允许重叠等。Pinecone 的这篇博客 <a target="_blank" rel="noopener" href="https://www.pinecone.io/learn/chunking-strategies/" title="Chunking Strategies for LLM Applications">Chunking Strategies for LLM Applications</a> 中就给出了一些在设计分块策略时需要考虑的因素。</p>
<ul>
<li><strong>原始内容的特点</strong>：原始内容是长文 ( 博客文章、书籍等 ) 还是短文 ( 推文、即时消息等 )，是什么格式 ( HTML、Markdown、Code 还是 LaTeX 等 )，不同的内容特点可能会适用不同的分块策略；</li>
<li><strong>后续使用的索引方法</strong>：目前最常用的索引是对分块后的内容进行向量索引，那么不同的向量嵌入模型可能有其适用的分块大小，比如 <strong>sentence-transformer</strong> 模型比较适合对句子级别的内容进行嵌入，OpenAI 的 <strong>text-embedding-ada-002</strong> 模型比较适合的分块大小在 256~512 个标记数量；</li>
<li><strong>问题的长度</strong>：问题的长度需要考虑，因为需要基于问题去检索出相关的文本片段；</li>
<li><strong>检索出的相关内容在回复生成阶段的使用方法</strong>：如果是直接把检索出的相关内容作为 Prompt 的一部分提供给 LLM，那么 LLM 的输入长度限制在设计分块大小时就需要考虑。</li>
</ul>
<h4 id="分块实现方法"><a href="#分块实现方法" class="headerlink" title="分块实现方法"></a>分块实现方法</h4><p>那么文本分块具体如何实现？一般来说，实现文本分块的整体流程如下:</p>
<ol>
<li>将原始的长文本切分成小的语义单元，这里的语义单元通常是句子级别或者段落级别；</li>
<li>将这些小的语义单元融合成更大的块，直到达到设定的块大小 ( Chunk Size )，就将该块作为独立的文本片段；</li>
<li>迭代构建下一个文本片段，一般相邻的文本片段之间会设置重叠，以保持语义的连贯性。</li>
</ol>
<p>那如何把原始的长文本切分成小的语义单元? 最常用的是基于分割符进行切分，比如句号 ( <code>.</code>)、换行符 ( <code>\n</code> )、空格等。除了可以利用单个分割符进行简单切分，还可以定义一组分割符进行迭代切分，比如定义 <code>[&quot;\n\n&quot;, &quot;\n&quot;, &quot; &quot;, &quot;&quot;]</code> 这样一组分隔符，切分的时候先利用第一个分割符进行切分 ( 实现类似按段落切分的效果 )，第一次切分完成后，对于超过预设大小的块，继续使用后面的分割符进行切分，依此类推。这种切分方法能比较好地保持原始文本的层次结构。</p>
<p>对于一些结构化的文本，比如代码，Markdown，LaTeX 等文本，在进行切分的时候可能需要单独进行考虑:</p>
<ul>
<li>比如 Python 代码文件，分割符中可能就需要加入类似 <code>\nclass</code>，<code>\ndef</code> 这种来保证类和函数代码块的完整性；</li>
<li>比如 Markdown 文件，是通过不同层级的 Header 进行组织的，即不同数量的 # 符号，在切分时就可以通过使用特定的分割符来维持这种层级结构。</li>
</ul>
<p><strong>文本块大小的设定也是分块策略需要考虑的重要因素</strong>，太大或者太小都会影响最终回复生成的效果。文本块大小的计算方法，最常用的可以直接<strong>基于字符数进行统计 ( Character-level )</strong>，也可以<strong>基于标记数进行统计 ( Token-level )</strong>。至于如何确定合适的分块大小，这个因场景而异，很难有一个统一的标准，可以通过评估不同分块大小的效果来进行选择。</p>
<p>上面提到的一些分块方法在 <a target="_blank" rel="noopener" href="https://python.langchain.com/docs/modules/data_connection/document_transformers/" title="LangChain">LangChain</a> 中都有相应的实现。比如下面的代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter, Language</span><br><span class="line"></span><br><span class="line"><span class="comment"># text split</span></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    <span class="comment"># Set a really small chunk size, just to show.</span></span><br><span class="line">    chunk_size = <span class="number">100</span>,</span><br><span class="line">    chunk_overlap  = <span class="number">20</span>,</span><br><span class="line">    length_function = <span class="built_in">len</span>,</span><br><span class="line">    add_start_index = <span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># code split</span></span><br><span class="line">python_splitter = RecursiveCharacterTextSplitter.from_language(</span><br><span class="line">            language=Language.PYTHON, </span><br><span class="line">            chunk_size=<span class="number">50</span>, </span><br><span class="line">            chunk_overlap=<span class="number">0</span>  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># markdown split</span></span><br><span class="line">md_splitter = RecursiveCharacterTextSplitter.from_language(  </span><br><span class="line">            language=Language.MARKDOWN, </span><br><span class="line">            chunk_size=<span class="number">60</span>, </span><br><span class="line">            chunk_overlap=<span class="number">0</span>  </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="（3）数据索引"><a href="#（3）数据索引" class="headerlink" title="（3）数据索引"></a>（3）数据索引</h3><p>经过前面的数据读取和文本分块操作后，接着就需要对处理好的数据进行索引。<strong>索引是一种数据结构，用于快速检索出与用户查询相关的文本内容</strong>。它是检索增强 LLM 的核心基础组件之一。</p>
<p>下面介绍几种常见的索引结构。为了说明不同的索引结构，引入节点(Node)的概念。在这里，节点就是前面步骤中对文档切分后生成的文本块(Chunk)。下面的索引结构图来自 LlamaIndex 的文档<a target="_blank" rel="noopener" href="https://gpt-index.readthedocs.io/en/latest/core_modules/data_modules/index/index_guide.html" title="How Each Index Works">How Each Index Works</a>。</p>
<h4 id="1）链式索引"><a href="#1）链式索引" class="headerlink" title="1）链式索引"></a>1）链式索引</h4><p>链式索引<strong>通过链表的结构对文本块进行顺序索引</strong>。在后续的检索和生成阶段，可以简单地顺序遍历所有节点，也可以基于关键词进行过滤。</p>
<p><img src="image/_duij-g5vy_05Oc6DaHcB.webp" alt=""></p>
<p><img src="image/j6qrc_7jq1_757nASmPoB.webp" alt=""></p>
<p><img src="image/xsedk--wv0_wkOzAA_t4a.webp" alt=""></p>
<h4 id="2）树索引"><a href="#2）树索引" class="headerlink" title="2）树索引"></a>2）树索引</h4><p>树索引<strong>将一组节点 ( 文本块 ) 构建成具有层级的树状索引结构</strong>，其从叶节点 (原始文本块) 向上构建，<strong>每个父节点都是子节点的摘要</strong>。在检索阶段，既可以从根节点向下进行遍历，也可以直接利用根节点的信息。<strong>树索引提供了一种更高效地查询长文本块的方式，它还可以用于从文本的不同部分提取信息</strong>。与链式索引不同，树索引无需按顺序查询。</p>
<p><img src="image/z37i04np4y_nAtkMWj55Z.webp" alt=""></p>
<p><img src="image/rx_3_v6bga__UGJ5JmLRY.png" alt=""></p>
<h4 id="3）关键词表索引"><a href="#3）关键词表索引" class="headerlink" title="3）关键词表索引"></a>3）关键词表索引</h4><p>关键词表索引<strong>从每个节点中提取关键词，构建了每个关键词到相应节点的多对多映射，意味着每个关键词可能指向多个节点，每个节点也可能包含多个关键词</strong>。在检索阶段，可以基于用户查询中的关键词对节点进行筛选。</p>
<p><img src="image/36wmybb209_p1QxEE3TfW.webp" alt=""></p>
<p><img src="image/-s3r95515f_8Kef2oNxBn.webp" alt=""></p>
<h4 id="4）向量索引"><a href="#4）向量索引" class="headerlink" title="4）向量索引"></a>4）向量索引</h4><p>向量索引是<strong>当前最流行的一种索引方法</strong>。这种方法一般利用<strong>文本嵌入模型</strong> ( Text Embedding Model ) 将文本块映射成一个固定长度的向量，然后存储在<strong>向量数据库</strong>中。检索的时候，对用户查询文本采用同样的文本嵌入模型映射成向量，然后基于向量相似度计算获取最相似的一个或者多个节点。</p>
<p><img src="image/hvtl-j3m-w_G0N6aLK_DS.webp" alt=""></p>
<p><img src="image/i86iadgfwk_EvF_HDxcns.webp" alt=""></p>
<p>上面的表述中涉及到向量索引和检索中三个重要的概念: <strong>文本嵌入模型</strong>、<strong>相似向量检索</strong>和<strong>向量数据库</strong>。下面一一进行详细说明。</p>
<h5 id="文本嵌入模型"><a href="#文本嵌入模型" class="headerlink" title="文本嵌入模型"></a>文本嵌入模型</h5><p>文本嵌入模型 ( Text Embedding Model ) 将非结构化的文本转换成结构化的向量 ( Vector )，目前常用的是学习得到的<strong>稠密向量</strong>。</p>
<p><img src="image/0nt5dmo6g-_-wqyyXtkom.svg" alt=""></p>
<p>当前有很多文本嵌入模型可供选择，比如</p>
<ul>
<li>早期的 Word2Vec、GloVe 模型等，目前很少用。</li>
<li>基于孪生 BERT 网络预训练得到的 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1908.10084" title="Sentence Transformers">Sentence Transformers</a> 模型，对句子的嵌入效果比较好</li>
<li>OpenAI 提供的 <a target="_blank" rel="noopener" href="https://openai.com/blog/new-and-improved-embedding-model" title="text-embedding-ada-002">text-embedding-ada-002</a> 模型，嵌入效果表现不错，且可以处理最大 8191 标记长度的文本</li>
<li><a target="_blank" rel="noopener" href="https://instructor-embedding.github.io/" title="Instructor">Instructor</a> 模型，这是一个经过指令微调的文本嵌入模型，可以根据任务(例如分类、检索、聚类、文本评估等)和领域(例如科学、金融等)，提供任务指令而生成相对定制化的文本嵌入向量，无需进行任何微调</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FlagOpen/FlagEmbedding/blob/master/README_zh.md" title="BGE">BGE</a>模型: 由智源研究院开源的中英文语义向量模型，目前在MTEB中英文榜单都排在第一位。</li>
</ul>
<p>下面就是评估文本嵌入模型效果的榜单 <a target="_blank" rel="noopener" href="https://huggingface.co/spaces/mteb/leaderboard" title="MTEB Leaderboard">MTEB Leaderboard</a> (截止到 2023-08-18 )。值得说明的是，这些现成的文本嵌入模型没有针对特定的下游任务进行微调，所以不一定在下游任务上有足够好的表现。最好的方式一般是在下游特定的数据上重新训练或者微调自己的文本嵌入模型。</p>
<p><img src="image/knuloe5g5l_tCORu5NXuS.png" alt=""></p>
<h5 id="相似向量检索"><a href="#相似向量检索" class="headerlink" title="相似向量检索"></a>相似向量检索</h5><p>相似向量检索要解决的问题是给定一个查询向量，如何从候选向量中准确且高效地检索出与其相似的一个或多个向量。首先是<strong>相似性度量</strong>方法的选择，可以采用余弦相似度、点积、欧式距离、汉明距离等，通常情况下可以直接使用<strong>余弦相似度</strong>。其次是相似性检索算法和实现方法的选择，候选向量的数量量级、检索速度和准确性的要求、内存的限制等都是需要考虑的因素。</p>
<p>当候选向量的数量比较少时，比如只有几万个向量，那么 Numpy 库就可以实现相似向量检索，实现简单，准确性高，速度也很快。国外有个博主做了个简单的基准测试发现 <a target="_blank" rel="noopener" href="https://www.ethanrosenthal.com/2023/04/10/nn-vs-ann/" title="Do you actually need a vector database">Do you actually need a vector database</a> ，当候选向量数量在 10 万量级以下时，通过对比 Numpy 和另一种高效的近似最近邻检索实现库 <a target="_blank" rel="noopener" href="https://github.com/nmslib/hnswlib" title="Hnswlib">Hnswlib</a> ，发现在检索效率上并没有数量级的差异，但 Numpy 的实现过程更简单。</p>
<p><img src="image/96q18_1xbq_JktZEFKFwV.png" alt=""></p>
<p>下面就是使用 Numpy 的一种简单实现代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># candidate_vecs: 2D numpy array of shape N x D</span></span><br><span class="line"><span class="comment"># query_vec: 1D numpy array of shape D</span></span><br><span class="line"><span class="comment"># k: number of top k similar vectors</span></span><br><span class="line"></span><br><span class="line">sim_scores = np.dot(candidate_vecs, query_vec)</span><br><span class="line">topk_indices = np.argsort(sim_scores)[::-<span class="number">1</span>][:k]</span><br><span class="line">topk_values = sim_scores[topk_indices]</span><br></pre></td></tr></table></figure>
<p>对于大规模向量的相似性检索，使用 Numpy 库就不合适，需要使用更高效的实现方案。Facebook团队开源的 <a target="_blank" rel="noopener" href="https://github.com/facebookresearch/faiss" title="Faiss">Faiss</a> 就是一个很好的选择。Faiss 是一个用于高效相似性搜索和向量聚类的库，它实现了在任意大小的向量集合中进行搜索的很多算法，除了可以在CPU上运行，有些算法也支持GPU加速。Faiss 包含多种相似性检索算法，具体使用哪种算法需要综合考虑数据量、检索频率、准确性和检索速度等因素。</p>
<p>Pinecone 的这篇博客 <a target="_blank" rel="noopener" href="https://www.pinecone.io/learn/series/faiss/vector-indexes/" title="Nearest Neighbor Indexes for Similarity Search">Nearest Neighbor Indexes for Similarity Search</a> 对 Faiss 中常用的几种索引进行了详细介绍，下图是几种索引在不同维度下的定性对比:</p>
<p><img src="image/xi5bi0eqmz_L-AQ2yyJ6K.png" alt=""></p>
<h5 id="向量数据库"><a href="#向量数据库" class="headerlink" title="向量数据库"></a>向量数据库</h5><p>上面提到的基于 Numpy 和 Faiss 实现的向量相似检索方案，如果应用到实际产品中，可能还缺少一些功能，比如：</p>
<ul>
<li>数据托管和备份</li>
<li>数据管理，比如数据的插入、删除和更新</li>
<li>向量对应的原始数据和元数据的存储</li>
<li>可扩展性，包括垂直和水平扩展</li>
</ul>
<p>所以<strong>向量数据库</strong>应运而生。简单来说，<strong>向量数据库是一种专门用于存储、管理和查询向量数据的数据库，可以实现向量数据的相似检索、聚类等</strong>。目前比较流行的向量数据库有 <a target="_blank" rel="noopener" href="https://www.pinecone.io/" title="Pinecone">Pinecone</a>、<a target="_blank" rel="noopener" href="https://vespa.ai/" title="Vespa">Vespa</a>、<a target="_blank" rel="noopener" href="https://weaviate.io/" title="Weaviate">Weaviate</a>、<a target="_blank" rel="noopener" href="https://milvus.io/" title="Milvus">Milvus</a>、<a target="_blank" rel="noopener" href="https://www.trychroma.com/" title="Chroma">Chroma</a> 、<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/vdb" title="Tencent Cloud VectorDB">Tencent Cloud VectorDB</a>等，大部分都提供开源产品。</p>
<p>Pinecone 的这篇博客 <a target="_blank" rel="noopener" href="https://www.pinecone.io/learn/vector-database/" title="What is a Vector Database">What is a Vector Database</a> 就对向量数据库的相关原理和组成进行了比较系统的介绍，下面这张图就是文章中给出的一个向量数据库常见的数据处理流程:</p>
<p><img src="image/fprd8zqxkt_4ZF8ZX7Qp-.png" alt=""></p>
<ol>
<li><strong>索引</strong>: 使用乘积量化 ( Product Quantization ) 、局部敏感哈希 ( LSH )、HNSW 等算法对向量进行索引，这一步将向量映射到一个数据结构，以实现更快的搜索。</li>
<li><strong>查询</strong>: 将查询向量和索引向量进行比较，以找到最近邻的相似向量。</li>
<li><strong>后处理</strong>: 有些情况下，向量数据库检索出最近邻向量后，对其进行后处理后再返回最终结果。</li>
</ol>
<p>向量数据库的使用比较简单，下面是使用 Python 操作 Pinecone 向量数据库的示例代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install python pinecone client</span></span><br><span class="line"><span class="comment"># pip install pinecone-client</span></span><br><span class="line"><span class="keyword">import</span> pinecone </span><br><span class="line"><span class="comment"># initialize pinecone client</span></span><br><span class="line">pinecone.init(api_key=<span class="string">&quot;YOUR_API_KEY&quot;</span>, environment=<span class="string">&quot;YOUR_ENVIRONMENT&quot;</span>)</span><br><span class="line"><span class="comment"># create index </span></span><br><span class="line">pinecone.create_index(<span class="string">&quot;quickstart&quot;</span>, dimension=<span class="number">8</span>, metric=<span class="string">&quot;euclidean&quot;</span>)</span><br><span class="line"><span class="comment"># connect to the index</span></span><br><span class="line">index = pinecone.Index(<span class="string">&quot;quickstart&quot;</span>)</span><br><span class="line"><span class="comment"># Upsert sample data (5 8-dimensional vectors) </span></span><br><span class="line">index.upsert([ </span><br><span class="line">        (<span class="string">&quot;A&quot;</span>, [<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>]), </span><br><span class="line">        (<span class="string">&quot;B&quot;</span>, [<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]), </span><br><span class="line">        (<span class="string">&quot;C&quot;</span>, [<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>]), </span><br><span class="line">        (<span class="string">&quot;D&quot;</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>]), </span><br><span class="line">        (<span class="string">&quot;E&quot;</span>, [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>]) </span><br><span class="line">      ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># query</span></span><br><span class="line">index.query( </span><br><span class="line">      vector=[<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>], </span><br><span class="line">      top_k=<span class="number">3</span>, </span><br><span class="line">      include_values=<span class="literal">True</span> </span><br><span class="line">      ) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns: </span></span><br><span class="line"><span class="comment"># &#123;&#x27;matches&#x27;: [&#123;&#x27;id&#x27;: &#x27;C&#x27;, </span></span><br><span class="line"><span class="comment">#               &#x27;score&#x27;: 0.0, </span></span><br><span class="line"><span class="comment">#               &#x27;values&#x27;: [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]&#125;, </span></span><br><span class="line"><span class="comment">#              &#123;&#x27;id&#x27;: &#x27;D&#x27;, </span></span><br><span class="line"><span class="comment">#               &#x27;score&#x27;: 0.0799999237, </span></span><br><span class="line"><span class="comment">#               &#x27;values&#x27;: [0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4]&#125;, </span></span><br><span class="line"><span class="comment">#              &#123;&#x27;id&#x27;: &#x27;B&#x27;, </span></span><br><span class="line"><span class="comment">#               &#x27;score&#x27;: 0.0800000429, </span></span><br><span class="line"><span class="comment">#               &#x27;values&#x27;: [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2]&#125;], </span></span><br><span class="line"><span class="comment"># &#x27;namespace&#x27;: &#x27;&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delete index </span></span><br><span class="line">pinecone.delete_index(<span class="string">&quot;quickstart&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="2-2查询和检索模块"><a href="#2-2查询和检索模块" class="headerlink" title="2.2查询和检索模块"></a>2.2查询和检索模块</h2><h3 id="（1）查询变换"><a href="#（1）查询变换" class="headerlink" title="（1）查询变换"></a>（1）查询变换</h3><p>查询文本的表达方法直接影响着检索结果，微小的文本改动都可能会得到天差万别的结果。直接用原始的查询文本进行检索在很多时候可能是简单有效的，但有时候可能需要对查询文本进行一些变换，以得到更好的检索结果，从而更可能在后续生成更好的回复结果。下面列出几种常见的查询变换方式。</p>
<h4 id="1）变换一-同义改写"><a href="#1）变换一-同义改写" class="headerlink" title="1）变换一: 同义改写"></a>1）变换一: 同义改写</h4><p>将原始查询改写成相同语义下不同的表达方式，改写工作可以调用 LLM 完成。比如对于这样一个原始查询:  <code>What are the approaches to Task Decomposition?</code>，可以改写成下面几种同义表达:</p>
<blockquote>
<p>How can Task Decomposition be approached?<br>What are the different methods for Task Decomposition?<br>What are the various approaches to decomposing tasks?</p>
</blockquote>
<p>对于每种查询表达，分别检索出一组相关文档，然后对所有检索结果进行去重合并，从而得到一个更大的候选相关文档集合。通过将同一个查询改写成多个同义查询，能够克服单一查询的局限，获得更丰富的检索结果集合。</p>
<h4 id="2）变换二-查询分解"><a href="#2）变换二-查询分解" class="headerlink" title="2）变换二: 查询分解"></a>2）变换二: 查询分解</h4><p>有相关研究表明 ( <a target="_blank" rel="noopener" href="https://ofir.io/self-ask.pdf" title="self-ask">self-ask</a>，<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2210.03629" title="ReAct">ReAct</a> )，LLM 在回答复杂问题时，如果将复杂问题分解成相对简单的子问题，回复表现会更好。这里又可以分成<strong>单步分解</strong>和<strong>多步分解</strong>。</p>
<p><strong>单步分解</strong>将一个复杂查询转化为多个简单的子查询，融合每个子查询的答案作为原始复杂查询的回复。</p>
<p><img src="image/w9_m9smu46_PYSXf7jYDM.png" alt=""></p>
<p>对于<strong>多步分解</strong>，给定初始的复杂查询，会一步一步地转换成多个子查询，结合前一步的回复结果生成下一步的查询问题，直到问不出更多问题为止。最后结合每一步的回复生成最终的结果。</p>
<p><img src="image/pagdp_5q1__2gyCnas6Fz.png" alt=""></p>
<h4 id="3）变换三-HyDE"><a href="#3）变换三-HyDE" class="headerlink" title="3）变换三: HyDE"></a>3）变换三: HyDE</h4><p><a target="_blank" rel="noopener" href="http://boston.lti.cs.cmu.edu/luyug/HyDE/HyDE.pdf" title="HyDE">HyDE</a>，全称叫 Hypothetical Document Embeddings，给定初始查询，<strong>首先利用 LLM 生成一个假设的文档或者回复，然后以这个假设的文档或者回复作为新的查询进行检索</strong>，而不是直接使用初始查询。这种转换在没有上下文的情况下可能会生成一个误导性的假设文档或者回复，从而可能得到一个和原始查询不相关的错误回复。下面是论文中给出的一个例子:</p>
<p><img src="image/3ig65l2ybq_07U_nQ5Ur7.png" alt=""></p>
<h3 id="（2）排序和后处理"><a href="#（2）排序和后处理" class="headerlink" title="（2）排序和后处理"></a>（2）排序和后处理</h3><p>经过前面的检索过程可能会得到很多相关文档，就需要进行筛选和排序。常用的筛选和排序策略包括：</p>
<ul>
<li>基于相似度分数进行过滤和排序</li>
<li>基于关键词进行过滤，比如限定包含或者不包含某些关键词</li>
<li>让 LLM 基于返回的相关文档及其相关性得分来重新排序</li>
<li>基于时间进行过滤和排序，比如只筛选最新的相关文档</li>
<li>基于时间对相似度进行加权，然后进行排序和筛选</li>
</ul>
<h2 id="2-3-回复生成模块"><a href="#2-3-回复生成模块" class="headerlink" title="2.3 回复生成模块"></a>2.3 回复生成模块</h2><h3 id="（1）回复生成策略"><a href="#（1）回复生成策略" class="headerlink" title="（1）回复生成策略"></a>（1）回复生成策略</h3><p>检索模块基于用户查询检索出相关的文本块，回复生成模块让 LLM 利用检索出的相关信息来生成对原始查询的回复。LlamaIndex 中有给出一些不同的回复生成策略。</p>
<p>一种策略是依次结合每个检索出的相关文本块，每次不断修正生成的回复。这样的话，有多少个独立的相关文本块，就会产生多少次的 LLM 调用。另一种策略是在每次 LLM 调用时，尽可能多地在 Prompt 中填充文本块。如果一个 Prompt 中填充不下，则采用类似的操作构建多个 Prompt，多个 Prompt 的调用可以采用和前一种相同的回复修正策略。</p>
<h3 id="（2）回复生成-Prompt-模板"><a href="#（2）回复生成-Prompt-模板" class="headerlink" title="（2）回复生成 Prompt 模板"></a>（2）回复生成 Prompt 模板</h3><p>下面是 LlamaIndex 中提供的一个生成回复的 Prompt 模板。从这个模板中可以看到，可以用一些分隔符 ( 比如 ——— ) 来区分相关信息的文本，还可以指定 LLM 是否需要结合它自己的知识来生成回复，以及当提供的相关信息没有帮助时，要不要回复等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Context information is below.</span></span><br><span class="line"><span class="string">---------------------</span></span><br><span class="line"><span class="string"><span class="subst">&#123;context_str&#125;</span></span></span><br><span class="line"><span class="string">---------------------</span></span><br><span class="line"><span class="string">Using both the context information and also using your own knowledge, answer the question: <span class="subst">&#123;query_str&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If the context isn&#x27;t helpful, you can/don’t answer the question on your own.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>下面的 Prompt 模板让 LLM 不断修正已有的回复。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">The original question is as follows: <span class="subst">&#123;query_str&#125;</span></span></span><br><span class="line"><span class="string">We have provided an existing answer: <span class="subst">&#123;existing_answer&#125;</span></span></span><br><span class="line"><span class="string">We have the opportunity to refine the existing answer (only if needed) with some more context below.</span></span><br><span class="line"><span class="string">------------</span></span><br><span class="line"><span class="string"><span class="subst">&#123;context_str&#125;</span></span></span><br><span class="line"><span class="string">------------</span></span><br><span class="line"><span class="string">Using both the new context and your own knowledege, update or repeat the existing answer.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="3-案例分析和应用"><a href="#3-案例分析和应用" class="headerlink" title="3.案例分析和应用"></a>3.案例分析和应用</h1><h2 id="3-1-ChatGPT-检索插件"><a href="#3-1-ChatGPT-检索插件" class="headerlink" title="3.1 ChatGPT 检索插件"></a>3.1 ChatGPT 检索插件</h2><p>ChatGPT 检索插件 <a target="_blank" rel="noopener" href="https://github.com/openai/chatgpt-retrieval-plugin" title="ChatGPT Retrieval Plugin">ChatGPT Retrieval Plugin</a> 是 OpenAI 官方给出的一个通过检索来增强 LLM 的范例，实现了让 ChatGPT 访问私有知识的一种途径，其在 Github 上的开源仓库短时间内获得了大量关注。下面是 ChatGPT 检索插件内部原理的一张示意图(<a target="_blank" rel="noopener" href="https://techcommunity.microsoft.com/t5/azure-database-for-postgresql/openai-chatgpt-retrieval-plugin-and-postgresql-on-azure/ba-p/3826411" title="图片来源: openai-chatgpt-retrieval-plugin-and-postgresql-on-azure">图片来源: openai-chatgpt-retrieval-plugin-and-postgresql-on-azure</a>)。</p>
<p><img src="image/zx2o6-r03j_nikEYfs-nZ.png" alt=""></p>
<p>在 API 接口设计上，检索插件提供了下面几种接口:</p>
<ul>
<li><code>/upsert</code>: 该接口将上传的一个或多个文本文档，先切分成文本块，每个文本块大小在 200 个 Token，然后利用 OpenAI 的 文本嵌入模型将文本块转换成向量，最后连同原始文本和元信息存储在向量数据库中，代码仓库中实现了对几乎所有主流向量类数据库的支持。</li>
<li><code>/upsert-file</code>: 该接口允许上传 PDF、TXT、DOCX、PPTX 和 MD 格式的单个文件，先转换成纯文本后，后续处理流程和 <code>/upsert</code> 接口一样。</li>
<li><code>/query</code>: 该接口实现对给定的查询，返回和查询最相关的几个文本块，实现原理也是基于相似向量检索。用户可以在请求中通过 <code>filter</code> 参数对文档进行过滤，通过 <code>top_k</code> 参数指定返回的相关文本块数量。</li>
<li><code>/delete</code>: 该接口实现从向量数据库中对一个或多个文档进行删除操作。</li>
</ul>
<h2 id="3-2-LlamaIndex-和-LangChain"><a href="#3-2-LlamaIndex-和-LangChain" class="headerlink" title="3.2 LlamaIndex 和 LangChain"></a>3.2 LlamaIndex 和 LangChain</h2><p><a target="_blank" rel="noopener" href="https://gpt-index.readthedocs.io/en/latest/index.html#" title="LlamaIndex">LlamaIndex</a> 是一个服务于 LLM 应用的数据框架，提供外部数据源的导入、结构化、索引、查询等功能，这篇文章的结构和内容有很大一部分是参考 LlamaIndex 的文档，文章中提到的很多模块、算法和策略，LlamaIndex 基本都有对应的实现，提供了相关的高阶和低阶 API。</p>
<p>LlamaIndex 主要包含以下组件和特性：</p>
<ul>
<li>数据连接器：能从多种数据源中导入数据，有个专门的项目 <a target="_blank" rel="noopener" href="https://llamahub.ai/" title="Llama Hub">Llama Hub</a>，可以连接多种来源的数据</li>
<li>数据索引：支持对读取的数据进行多种不同的索引，便于后期的检索</li>
<li>查询和对话引擎：既支持单轮形式的查询交互引擎，也支持多轮形式的对话交互引擎</li>
<li>应用集成：可以方便地与一些流行的应用进行集成，比如 ChatGPT、LangChain、Flask、Docker等</li>
</ul>
<p>下面是 LlamaIndex 整体框架的一张示意图。</p>
<p><img src="image/88xh886jei_ZHkF6FyLQQ.jpeg" alt=""></p>
<p>除了 LlamaIndex，<a target="_blank" rel="noopener" href="https://python.langchain.com/docs/get_started/introduction.html" title="LangChain">LangChain</a> 也是当前流行的一种 LLM 应用开发框架，其中也包含一些检索增强 LLM 的相关组件，不过相比较而言，LlamaIndex 更侧重于检索增强 LLM 这一相对小的领域，而 LangChain 覆盖的领域更广，比如会包含 LLM 的链式应用、Agent 的创建和管理等。下面这张图就是 LangChain 中 <a target="_blank" rel="noopener" href="https://python.langchain.com/docs/modules/data_connection/" title="Retrieval">Retrieval</a> 模块的整体流程示意图，包含数据加载、变换、嵌入、向量存储和检索，整体处理流程和 LlamaIndex 是一样的。</p>
<p><img src="image/etz_ewki3z_QWUVCi861U.jpeg" alt=""></p>
<h2 id="3-3-Github-Copilot-分析"><a href="#3-3-Github-Copilot-分析" class="headerlink" title="3.3 Github Copilot 分析"></a>3.3 Github Copilot 分析</h2><p><a target="_blank" rel="noopener" href="https://github.com/features/copilot" title="Github Copilot">Github Copilot</a> 是一款 AI 辅助编程工具。如果使用过就会发现，Github Copilot 可以根据代码的上下文来帮助用户自动生成或者补全代码，有时候可能刚写下类名或者函数名，又或者写完函数注释，Copilot 就给出了生成好的代码，并且很多时候可能就是我们想要实现的代码。由于 Github Copilot 没有开源，网上有人对其 VSCode 插件进行了逆向分析，比如 <a target="_blank" rel="noopener" href="https://thakkarparth007.github.io/copilot-explorer/posts/copilot-internals" title="copilot internals">copilot internals</a> 和 <a target="_blank" rel="noopener" href="https://github.com/mengjian-github/copilot-analysis" title="copilot analysis">copilot analysis</a>，让我们可以对 Copilot 的内部实现有个大概的了解。</p>
<p>简单来说，<strong>Github Copilot 插件会收集用户在 VSCode 编程环境中的多种上下文信息构造 Prompt，然后把构造好的 Prompt 发送给代码生成模型 ( 比如 Codex )，得到补全后的代码，显示在编辑器中</strong>。如何检索出相关的上下文信息 ( Context ) 就是其中很重要的一个环节。Github Copilot 算是检索增强 LLM 在 AI 辅助编程方向的一个应用。</p>
<p>需要说明的是，上面提到的两份逆向分析是几个月之前做的，Github Copilpot 目前可能已经做了很多的更新和迭代，另外分析是原作者阅读理解逆向后的代码得到的，所以可能会产生一些理解上的偏差。而下面的内容是我结合那两份分析产生的，因此有些地方可能是不准确甚至是错误的，但不妨碍我们通过 Copilot 这个例子来理解上下文信息对增强 LLM 输出结果的重要性，以及学习一些上下文相关信息检索的实践思路。</p>
<p>下面是一个 Prompt 的示例，可以看到包含前缀代码信息 ( prefix )，后缀代码信息 ( suffix )，生成模式 ( isFimEnabled )，以及 Prompt 不同组成元素的起始位置信息 ( promptElementRanges )。</p>
<p><img src="image/zl450wocuu_X6MX8Y_7BL.png" alt=""></p>
<p>抛开代码生成模型本身的效果不谈，Prompt 构造的好坏很大程度上会影响代码补全的效果，而上下文相关信息 ( Context ) 的提取和构成很大程度上又决定了 Prompt 构造的好坏。让我们来看一下 Github Copilot 的 Prompt 构造中有关上下文相关信息抽取的一些关键思路和实现。</p>
<p>Copilot 的 Prompt 包含不同类型的相关信息，包括</p>
<ul>
<li><code>BeforeCursor</code>：光标前的内容</li>
<li><code>AfterCursor</code>：光标后的内容</li>
<li><code>SimilarFile</code>：与当前文件相似度较高的代码片段</li>
<li><code>ImportedFile</code> ：import 依赖</li>
<li><code>LanguageMarker</code>：文件开头的语言标记</li>
<li><code>PathMarker</code>：文件的相对路径信息</li>
</ul>
<p>其中相似代码片段的抽取，会先获取最近访问过的多份同种语言的文件，作为抽取相似代码片段的候选文档。然后设定窗口大小 ( 比如默认为 60 行 ) 和步长 ( 比如默认为 1 行 )，以滑动窗口的方式将候选文档切分成代码块。接着计算每个切分后的代码块和当前文件的相似度，最后保留相似度较高的几个代码块。这里当前文件的获取是从当前光标往前截取窗口大小的内容，相似度的度量采用的是 <strong>Jaccard 系数</strong>，具体来说，会对代码块中的每一行进行分词，过滤常见的代码关键字 ( 比如 if, then, else, for 这些)，得到一个标记 ( Token ) 集合，然后就可以在当前代码块和候选代码块的 Token 集合之间计算 Jaccard 相似度。在 Copilot 的场景下，这种相似度的计算方式简单有效。<br>$J(A, B) = \frac{|A \cap B|}{|A \cup B|} = \frac{|A \cap B|}{|A| + |B| - |A \cap B|}$<br>上面的一篇分析文章中将 Prompt 的组成总结成下面的一张图。</p>
<p><img src="image/-7odlfea82_ZAUMsQpq0k.png" alt=""></p>
<p>构造好 Prompt 后，Copilot 还会判断是否有必要发起请求，代码生成模型的计算是非常耗费算力的，因此有必要过滤一些不必要的请求。其中一个判断是利用简单的线性回归模型对 Prompt 进行打分，当分数低于某个阈值时，请求就不会发出。这个线性回归模型利用的特征包括像代码语言、上一次代码补全建议是否被采纳或拒绝、上一次采纳或拒绝距现在的时长、光标左边的字符等。通过分析模型的权重，原作者给出了一些观察：</p>
<ul>
<li>一些编程语言的权重相对于其他语言权重要更高 ( php &gt; js &gt; python &gt; rust &gt; … )，PHP 权重最高，果然 <strong>PHP是世界上最好的语言</strong>( ^ _^ )。</li>
<li>右半边括号 ( 比如 <code>)</code>，<code>]</code> ) 的权重要低于左半边括号，这是符合逻辑的。</li>
</ul>
<p>通过对 Github Copilot 这个编程辅助工具的分析可以看到：</p>
<ul>
<li><strong>检索增强 LLM 的思路和技术在 Github Copilot 的实现中发挥着重要作用</strong></li>
<li>上下文相关信息 ( Context ) 可以是一个广义概念，可以是相关的文本或者代码片段，也可以是文件路径、相关依赖等，每个场景都可以定义其特定的上下文元素</li>
<li>相似性的度量和相似检索方法可以因场景而异，不一定所有场景都需要用余弦相似度，都需要通过向量相似检索的方式找出相关文档，比如 Copilot 的实现中就利用简单的 Jaccard 系数来计算分词后 Token 集合的相似度，简单高效。</li>
</ul>
<h2 id="3-4-文档和知识库的检索与问答"><a href="#3-4-文档和知识库的检索与问答" class="headerlink" title="3.4 文档和知识库的检索与问答"></a>3.4 文档和知识库的检索与问答</h2><p>检索增强 LLM 技术的一个典型应用是知识库或者文档问答，比如针对企业内部知识库或者一些文档的检索与问答等。这个应用方向目前已经出现了很多商业化和开源的产品。比如 <a target="_blank" rel="noopener" href="https://www.mendable.ai/" title="Mendable">Mendable</a> 就是一款商业产品，能提供基于文档的 AI 检索和问答能力。上面提到的 LlamaIndex 和 LangChain 项目官方文档的检索能力就是由 Mendable 提供的。下面就是一张使用截图，可以看到 Mendable 除了会给出生成的回复，也会附上参考链接。</p>
<p><img src="image/uepwk88u4-_r-vwUmM-d1.png" alt=""></p>
<p>除了商业产品，也有很多类似的开源产品。比如</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/danswer-ai/danswer" title="Danswer">Danswer</a>: 提供针对企业内部文档的问答功能，能实现多种来源的数据导入，支持传统的检索和基于 LLM 的问答，能智能识别用户的搜索意图，从而采用不同的检索策略，支持用户和文档的权限管理，以及支持Docker部署等</li>
<li><a target="_blank" rel="noopener" href="https://www.pandagpt.io/" title="PandaGPT">PandaGPT</a>: 支持用户上传文件，然后可以针对文件内容进行提问</li>
<li><a target="_blank" rel="noopener" href="https://fastgpt.run/" title="FastGPT">FastGPT</a>: 一个开源的基于 LLM 的 AI 知识库问答平台</li>
<li><a target="_blank" rel="noopener" href="https://github.com/StanGirard/quivr" title="Quivr">Quivr</a>: 这个开源项目能实现用户对个人文件或者知识库的检索和问答，期望成为用户的「第二大脑」</li>
<li><a target="_blank" rel="noopener" href="https://github.com/guangzhengli/ChatFiles" title="ChatFiles">ChatFiles</a>: 又一个基于 LLM 的文档问答开源项目</li>
</ul>
<p>下面这张图是 ChatFiles 项目的技术架构图，可以发现这类项目的基本模块和架构都很类似，基本都遵从检索增强 LLM 的思路，这类知识库问答应用几乎成为 LLM 领域的 <strong>Hello World</strong> 应用了。</p>
<p><img src="image/4x9fc4i_0r_bzpIRKAkpG.png" alt=""></p>
<h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h1><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/openai/chatgpt-retrieval-plugin" title="ChatGPT Retrieval Plugin">ChatGPT Retrieval Plugin</a> #project</li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/abs/2212.10496?ref=mattboegner.com" title="Hypothetical Document Embeddings">Hypothetical Document Embeddings</a> #paper</li>
<li><a target="_blank" rel="noopener" href="https://mattboegner.com/knowledge-retrieval-architecture-for-llms/" title="Knowledge Retrieval Architecture for LLM’s (2023)">Knowledge Retrieval Architecture for LLM’s (2023)</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://www.pinecone.io/learn/chunking-strategies/" title="Chunking Strategies for LLM Applications">Chunking Strategies for LLM Applications</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://python.langchain.com/docs/modules/data_connection/document_transformers/" title="LangChain Document Transformers">LangChain Document Transformers</a> #doc</li>
<li><a target="_blank" rel="noopener" href="https://gpt-index.readthedocs.io/en/latest/core_modules/data_modules/index/index_guide.html" title="LlamaIndex Index Guide">LlamaIndex Index Guide</a> #doc</li>
<li><a target="_blank" rel="noopener" href="https://fullstackdeeplearning.com/llm-bootcamp/spring-2023/augmented-language-models/" title="Full stack LLM Bootcamp: Augmented Language Models">Full stack LLM Bootcamp: Augmented Language Models</a> #course</li>
<li><a target="_blank" rel="noopener" href="https://www.pinecone.io/learn/series/faiss/vector-indexes/" title="Pinecone: vector indexes in faiss">Pinecone: vector indexes in faiss</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://www.pinecone.io/learn/vector-database/" title="Pinecone: what is a vector database">Pinecone: what is a vector database</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://blog.reachsumit.com/posts/2023/03/llm-for-text-ranking/" title="Zero and Few Shot Text Retrieval and Ranking Using Large Language Models">Zero and Few Shot Text Retrieval and Ranking Using Large Language Models</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://thakkarparth007.github.io/copilot-explorer/posts/copilot-internals" title="copilot internals">copilot internals</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://github.com/mengjian-github/copilot-analysis" title="copilot analysis">copilot analysis</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=A3iqOJHBQhM\&amp;ab_channel=LlamaIndex" title="Discover LlamaIndex: Key Components to Build QA Systems">Discover LlamaIndex: Key Components to Build QA Systems</a> #video</li>
<li><a target="_blank" rel="noopener" href="https://wangzwhu.github.io/home/file/acmmm-t-part3-ann.pdf" title="Billion scale approximate nearest neighbor search">Billion scale approximate nearest neighbor search</a> #slide</li>
<li><a target="_blank" rel="noopener" href="https://acl2023-retrieval-lm.github.io/" title="ACL 2023 Tutorial: Retrieval based LM">ACL 2023 Tutorial: Retrieval based LM</a> #slide</li>
<li><a target="_blank" rel="noopener" href="https://www.pinecone.io/blog/why-use-retrieval-instead-of-larger-context/" title="Pinecone: why use retrieval instead of larger context">Pinecone: why use retrieval instead of larger context</a> #blog</li>
<li><a target="_blank" rel="noopener" href="https://github.com/RUC-GSAI/YuLan-IR/tree/main/RETA-LLM" title="RETA-LLM">RETA-LLM</a> #project</li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=njzB6fm0U8g\&amp;ab_channel=LlamaIndex" title="Document Metadata and Local Models for Better, Faster Retrieval">Document Metadata and Local Models for Better, Faster Retrieval</a> #video</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://wdndev.github.io">Firefly</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wdndev.github.io/llms/llms_article/9.%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BALLM/">https://wdndev.github.io/llms/llms_article/9.检索增强LLM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Transformer/">Transformer</a><a class="post-meta__tags" href="/tags/LLMs/">LLMs</a></div><div class="post_share"><div class="social-share" data-image="/img/wdn_icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/llms/llms_idx/" title="LLMs 目录"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-05</div><div class="title">LLMs 目录</div></div></a></div><div><a href="/llms/llms_article/1.llm%E6%8E%A8%E7%90%86%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/" title="LLMs 推理优化技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">LLMs 推理优化技术</div></div></a></div><div><a href="/llms/llms_article/2.%E4%B8%BB%E6%B5%81%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E7%BB%86%E8%8A%82/" title="主流大语言模型的技术原理细节"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">主流大语言模型的技术原理细节</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-RAG%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.RAG基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA-LLM"><span class="toc-text">1.1 什么是检索增强 LLM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA-LLM-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1.2 检索增强 LLM 解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%95%BF%E5%B0%BE%E7%9F%A5%E8%AF%86"><span class="toc-text">（1）长尾知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A7%81%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-text">（2）私有数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E6%96%B0%E9%B2%9C%E5%BA%A6"><span class="toc-text">（3）数据新鲜度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%9D%A5%E6%BA%90%E9%AA%8C%E8%AF%81%E5%92%8C%E5%8F%AF%E8%A7%A3%E9%87%8A%E6%80%A7"><span class="toc-text">（4）来源验证和可解释性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E6%A8%A1%E5%9D%97"><span class="toc-text">2.关键模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9D%97"><span class="toc-text">2.1 数据和索引模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="toc-text">（1）数据获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%96%87%E6%9C%AC%E5%88%86%E5%9D%97"><span class="toc-text">（2）文本分块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">分块实现方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95"><span class="toc-text">（3）数据索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">1）链式索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-text">2）树索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A1%A8%E7%B4%A2%E5%BC%95"><span class="toc-text">3）关键词表索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E5%90%91%E9%87%8F%E7%B4%A2%E5%BC%95"><span class="toc-text">4）向量索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9E%8B"><span class="toc-text">文本嵌入模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E5%90%91%E9%87%8F%E6%A3%80%E7%B4%A2"><span class="toc-text">相似向量检索</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">向量数据库</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%A3%80%E7%B4%A2%E6%A8%A1%E5%9D%97"><span class="toc-text">2.2查询和检索模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9F%A5%E8%AF%A2%E5%8F%98%E6%8D%A2"><span class="toc-text">（1）查询变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%8F%98%E6%8D%A2%E4%B8%80-%E5%90%8C%E4%B9%89%E6%94%B9%E5%86%99"><span class="toc-text">1）变换一: 同义改写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%8F%98%E6%8D%A2%E4%BA%8C-%E6%9F%A5%E8%AF%A2%E5%88%86%E8%A7%A3"><span class="toc-text">2）变换二: 查询分解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%8F%98%E6%8D%A2%E4%B8%89-HyDE"><span class="toc-text">3）变换三: HyDE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%8E%92%E5%BA%8F%E5%92%8C%E5%90%8E%E5%A4%84%E7%90%86"><span class="toc-text">（2）排序和后处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%9B%9E%E5%A4%8D%E7%94%9F%E6%88%90%E6%A8%A1%E5%9D%97"><span class="toc-text">2.3 回复生成模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9B%9E%E5%A4%8D%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5"><span class="toc-text">（1）回复生成策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%9B%9E%E5%A4%8D%E7%94%9F%E6%88%90-Prompt-%E6%A8%A1%E6%9D%BF"><span class="toc-text">（2）回复生成 Prompt 模板</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-text">3.案例分析和应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ChatGPT-%E6%A3%80%E7%B4%A2%E6%8F%92%E4%BB%B6"><span class="toc-text">3.1 ChatGPT 检索插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-LlamaIndex-%E5%92%8C-LangChain"><span class="toc-text">3.2 LlamaIndex 和 LangChain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Github-Copilot-%E5%88%86%E6%9E%90"><span class="toc-text">3.3 Github Copilot 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%96%87%E6%A1%A3%E5%92%8C%E7%9F%A5%E8%AF%86%E5%BA%93%E7%9A%84%E6%A3%80%E7%B4%A2%E4%B8%8E%E9%97%AE%E7%AD%94"><span class="toc-text">3.4 文档和知识库的检索与问答</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%8F%82%E8%80%83"><span class="toc-text">4.参考</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Firefly</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">簡</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'oe7vzWxH80qwJJjWslYTCViT-gzGzoHsz',
      appKey: 'k89nSbK0BTbmzmpQottRHvNI',
      avatar: 'monsterid',
      serverURLs: 'https://oe7vzwxh.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async src="/js/title.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":180,"height":360,"hOffset":0,"vOffset":-100},"mobile":{"show":true},"react":{"opacity":0.85},"log":false});</script></body></html>