<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>4.Cython中扩展类 | 37.2° Blog</title><meta name="author" content="Firefly"><meta name="copyright" content="Firefly"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、Python类和扩展类之间的差异首先 Python 中 “一切皆对象”，怎么理解呢？首先在最基本的层次上，一个对象有三样东西：地址、值、类型，通过 id 函数可以获取地址并将每一个对象都区分开来，使用 type 获取类型。Python 中对象有很多属性，这些属性都放在自身的属性字典里面，这个字典可以通过 __dict__ 获取。调用对象的某一个属性的时候，可以通过 . 的方式来调用，Pytho">
<meta property="og:type" content="article">
<meta property="og:title" content="4.Cython中扩展类">
<meta property="og:url" content="https://wdndev.github.io/program_language/cython/4.Cython%E4%B8%AD%E6%89%A9%E5%B1%95%E7%B1%BB/index.html">
<meta property="og:site_name" content="37.2° Blog">
<meta property="og:description" content="1、Python类和扩展类之间的差异首先 Python 中 “一切皆对象”，怎么理解呢？首先在最基本的层次上，一个对象有三样东西：地址、值、类型，通过 id 函数可以获取地址并将每一个对象都区分开来，使用 type 获取类型。Python 中对象有很多属性，这些属性都放在自身的属性字典里面，这个字典可以通过 __dict__ 获取。调用对象的某一个属性的时候，可以通过 . 的方式来调用，Pytho">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wdndev.github.io/img/wdn_icon.png">
<meta property="article:published_time" content="2022-08-19T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-08T00:00:55.872Z">
<meta property="article:author" content="Firefly">
<meta property="article:tag" content="PL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdndev.github.io/img/wdn_icon.png"><link rel="shortcut icon" href="/img/wdn_icon.png"><link rel="canonical" href="https://wdndev.github.io/program_language/cython/4.Cython%E4%B8%AD%E6%89%A9%E5%B1%95%E7%B1%BB/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search/.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":100,"languages":{"author":"Author: Firefly","link":"Link: ","source":"Source: 37.2° Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '4.Cython中扩展类',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-02-08 08:00:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/wdn_icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">942</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Content</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/paper_reading/pr_content"><i class="fa-fw fas fa-newspaper"></i><span> Paper</span></a></li><li><a class="site-page child" href="/llms/llms_idx"><i class="fa-fw fa-regular fa-bookmark"></i><span> LLMs</span></a></li><li><a class="site-page child" href="/jupyter"><i class="fa-fw fa-solid fa-file"></i><span> Jupyter</span></a></li><li><a class="site-page child" href="/dsa/dsa_idx"><i class="fa-fw fas fa-tree"></i><span> Algorithm</span></a></li><li><a class="site-page child" href="/program_language/pl_idx"><i class="fa-fw fas fa-code"></i><span> PLs</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-calendar-days"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/daily/github/index"><i class="fa-fw fas fa-arrow-trend-up"></i><span> Github</span></a></li><li><a class="site-page child" href="/daily/hot_news/index"><i class="fa-fw fas fa-brands fa-message"></i><span> HotNews</span></a></li><li><a class="site-page child" href="/daily/hf/index"><i class="fa-fw fas fa-face-smile"></i><span> HF</span></a></li><li><a class="site-page child" href="/daily/domain/index"><i class="fa-fw fas fa-book-open"></i><span> Arxiv</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="37.2° Blog"><span class="site-name">37.2° Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Content</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/paper_reading/pr_content"><i class="fa-fw fas fa-newspaper"></i><span> Paper</span></a></li><li><a class="site-page child" href="/llms/llms_idx"><i class="fa-fw fa-regular fa-bookmark"></i><span> LLMs</span></a></li><li><a class="site-page child" href="/jupyter"><i class="fa-fw fa-solid fa-file"></i><span> Jupyter</span></a></li><li><a class="site-page child" href="/dsa/dsa_idx"><i class="fa-fw fas fa-tree"></i><span> Algorithm</span></a></li><li><a class="site-page child" href="/program_language/pl_idx"><i class="fa-fw fas fa-code"></i><span> PLs</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-calendar-days"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/daily/github/index"><i class="fa-fw fas fa-arrow-trend-up"></i><span> Github</span></a></li><li><a class="site-page child" href="/daily/hot_news/index"><i class="fa-fw fas fa-brands fa-message"></i><span> HotNews</span></a></li><li><a class="site-page child" href="/daily/hf/index"><i class="fa-fw fas fa-face-smile"></i><span> HF</span></a></li><li><a class="site-page child" href="/daily/domain/index"><i class="fa-fw fas fa-book-open"></i><span> Arxiv</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">4.Cython中扩展类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-08-19T16:00:00.000Z" title="Created 2022-08-20 00:00:00">2022-08-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-08T00:00:55.872Z" title="Updated 2026-02-08 08:00:55">2026-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PL/">PL</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PL/Cython/">Cython</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>44min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="4.Cython中扩展类"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="1、Python类和扩展类之间的差异"><a href="#1、Python类和扩展类之间的差异" class="headerlink" title="1、Python类和扩展类之间的差异"></a>1、Python类和扩展类之间的差异</h1><p>首先 Python 中 “一切皆对象”，怎么理解呢？首先在最基本的层次上，一个对象有三样东西：地址、值、类型，通过 id 函数可以获取地址并将每一个对象都区分开来，使用 type 获取类型。Python 中对象有很多属性，这些属性都放在自身的属性字典里面，这个字典可以通过 <code>__dict__</code> 获取。调用对象的某一个属性的时候，可以通过 <code>.</code> 的方式来调用，Python 也允许我们通过 class 关键字自定义一个类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.__name__)  <span class="comment"># A</span></span><br><span class="line">A.__name__ = <span class="string">&quot;B&quot;</span></span><br><span class="line"><span class="built_in">print</span>(A.__name__)  <span class="comment"># B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>.__name__ = <span class="string">&quot;INT&quot;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 内建类型 和 扩展类型 不允许修改属性</span></span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># can&#x27;t set attributes of built-in/extension type &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure>
<p>除了在 Python 中定义类，还可以直接使用 Python/C API 在 C 级别创建自己的类型，这样的类型称之为扩展类、或者扩展类型（说白了在 C 中实现的类就叫做扩展类）。</p>
<blockquote>
<p>Python 解释器本来就是 C 写的，所以可以在 C 的层面上面实现 Python 的任何对象，类也是如此。Python 中自定义的类和内置的类在 C 一级的结构是一致的，所以只需要按照 Python/C API 提供的标准来编写即可。但还是那句话，使用 C 来编写会比较麻烦，因为本质上就是写 C 语言。</p>
</blockquote>
<p>当操作扩展类的时候，操作的是编译好的静态代码，因此在访问内部属性的时候，可以实现快速的 C 一级的访问，这种访问可以显著的提高性能。但是在扩展类的实现、以及处理相应的实例对象和在纯 Python 中定义类是完全不同的，需要有专业的 Python/C API 的知识，不适合新手。</p>
<p>这也是 Cython 要增强 Python 类的原因：Cython 使得创建和操作扩展类就像操作 Python 中的类一样。在Cython中定义一个扩展类通过 cdef class 的形式，和 Python 中的常规类保持了高度的相似性。</p>
<blockquote>
<p>尽管在语法上有着相似之处，但是 cdef class 定义的类对所有方法和数据都有快速的 C 级别的访问，这也是和扩展类和 Python 中的普通类之间的一个最显著的区别。而且扩展类和 int、str、list 等内置的类都属于静态类，它们的属性是不可修改的。</p>
</blockquote>
<h1 id="2、Cython中的扩展类"><a href="#2、Cython中的扩展类" class="headerlink" title="2、Cython中的扩展类"></a>2、Cython中的扩展类</h1><p>写一个 Python 中的类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, width, height</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = width</span><br><span class="line">        <span class="variable language_">self</span>.height = height</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height</span><br></pre></td></tr></table></figure>
<p>这个类是在 Python 级别定义的，可以被 CPython 编译的。定义了矩形的宽和高，并且提供了一个方法，计算面积。这个类是可以动态修改的，可以指定任意的属性。</p>
<p>如果对这个 Python 类编译的话，那么得到的类依旧是一个纯 Python 类，而不是扩展类。所有的操作，仍然是通过动态调度通用的 Python 对象来实现的。只不过由于解释器的开销省去了，因此效率上会提升一点点，但是它无法从静态类型上获益，因为此时的 Cython 代码仍然需要在运行时动态调度来解析类型。</p>
<p>改成扩展类的话，需要这么做。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cython_test.pyx</span></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line"></span><br><span class="line">    cdef long width, height</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = w</span><br><span class="line">        <span class="variable language_">self</span>.height = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height</span><br></pre></td></tr></table></figure>
<p>此时的关键字使用的是<code>cdef class</code>，意思就是表示这个类不是一个普通的 Python 类，而是一个扩展类。内部代码，多了一个 <code>cdef long width, height</code>，这个是名称和 self 的属性是同名的，表示 self 中的 width、height 都必须是一个 long，或者说可以转为 C 中的 long 的 Python 对象。另外<strong>对于 cdef 来说，定义的类是可以被外部访问的，虽然函数不行、但类可以</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line">rect = cython_test.Rectangle(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.get_area())  <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    rect = cython_test.Rectangle(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># an integer is required</span></span><br></pre></td></tr></table></figure>
<p>注意：在 <code>__init__</code> 中实例化的属性，都必须在类中使用 cdef 声明，举个栗子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">	<span class="comment"># 这里我们只声明了width, 没有声明height, 那么是不是意味着这个height可以接收任意对象呢？</span></span><br><span class="line">    cdef long width</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = w</span><br><span class="line">        <span class="variable language_">self</span>.height = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height</span><br><span class="line"> <span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">rect = cython_test.Rectangle(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">File &quot;cython_test.pyx&quot;, line 7, in cython_test.Rectangle.__init__</span></span><br><span class="line"><span class="string">    self.height = h</span></span><br><span class="line"><span class="string">AttributeError: &#x27;cython_test.Rectangle&#x27; object has no attribute &#x27;height&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>凡是在没有在 cdef 中声明的，都不可以赋值给 self</strong>，可能有人发现了这不是访问，而是添加呀。添加一个属性咋啦，没咋，无论是获取还是赋值，<strong>self 中的属性必须使用 cdef 在类中声明</strong>。举一个Python 内置类型的例子吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a.xx = <span class="number">123</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;int&#x27; object has no attribute &#x27;xx&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>一样等价，扩展类和内建的类是同级别的，一个属性如果想通过 <code>self.</code> 的方式来调用，那么一定要在类里面通过 cdef 声明。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    cdef long width, height</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = w</span><br><span class="line">        <span class="variable language_">self</span>.height = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">rect = cython_test.Rectangle(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    rect.a = <span class="string">&quot;xx&quot;</span></span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;cython_test.Rectangle&#x27; object has no attribute &#x27;a&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果想动态修改、添加类型，那么需要解释器在解释的时候来动态操作</span></span><br><span class="line"><span class="string">但扩展类和内置的类是等价的，直接指向了C一级的结构，不需要解释器解释这一步，因此也失去了动态修改的能力</span></span><br><span class="line"><span class="string">也正因为如此，也能提高效率。因为很多时候，我们不需要动态修改。</span></span><br><span class="line"><span class="string">当一个类实例化之后，会给实例对象一个属性字典，通过__dict__获取，它的所有属性以及相关的值都会存储在这里</span></span><br><span class="line"><span class="string">其实获取一个实例对象的属性，本质上是从属性字典里面获取，instance.attr 等价于instance.__dict__[&quot;attr&quot;]，同理修改、创建也是。</span></span><br><span class="line"><span class="string">但是注意：这只是针对普通的 Python 类而言，但扩展类的实例对象内部是没有 __dict__ 的。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    rect.__dict__</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;cython_test.Rectangle&#x27; object has no attribute &#x27;__dict__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不光 __dict__, 你连 self 本身的属性都无法访问</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    rect.width</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;cython_test.Rectangle&#x27; object has no attribute &#x27;width&#x27;</span></span><br><span class="line"><span class="comment"># 提示我们 self 没有 width 属性，所以我们实例化之后再想修改是不行的，连获取都获取不到</span></span><br><span class="line"><span class="comment"># 只能调用它的一些方法罢了。</span></span><br></pre></td></tr></table></figure>
<p>所以内建的类和扩展类是完全类似的，其实例对象都没有属性字典，至于类本身是有属性字典的，但是这个字典不可修改。因为虽然叫属性字典，但它的类型实际上是一个 mappingproxy。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">int</span>.__dict__[<span class="string">&quot;a&quot;</span>] = <span class="number">123</span></span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cython_test.Rectangle.__dict__[<span class="string">&quot;a&quot;</span>] = <span class="number">123</span></span><br><span class="line"><span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;mappingproxy&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure>
<p>还是那句话，动态设置、修改、获取、删除属性，这些都是在解释器解释字节码的时候动态操作的，在解释的时候是允许你做一些这样的骚操作的。但是内置的类和扩展类是不需要解释这一步的，它们是彪悍的人生，直接指向了 C 一级的数据结构，因此也就丧失了这种动态的能力。</p>
<p>但是扩展类毕竟是自己指定的，如果想修改 self 的一些属性呢？答案是将其暴露给外界即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="comment"># 通过cdef public的方式进行声明即可</span></span><br><span class="line">    <span class="comment"># 这样的话就会暴露给外界了</span></span><br><span class="line">    cdef public long width, height</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = w</span><br><span class="line">        <span class="variable language_">self</span>.height = h</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">rect = cython_test.Rectangle(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.width)  <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(rect.get_area())  <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line">rect.width = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(rect.get_area())  <span class="comment"># 492</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    rect.__dict__</span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># &#x27;cython_test.Rectangle&#x27; object has no attribute &#x27;__dict__&#x27;</span></span><br><span class="line"><span class="comment"># 属性字典依旧是没有的</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>cdef public</code>声明的属性，是可以被外界获取并修改的，除了<code>cdef public</code>之外还有 <code>cdef readonly</code>，同样会将属性暴露给外界，但是只能访问不能修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">rect = cython_test.Rectangle(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.width)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    rect.width = <span class="number">123</span></span><br><span class="line"><span class="keyword">except</span> AttributeError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># attribute &#x27;width&#x27; of &#x27;cython_test.Rectangle&#x27; objects is not writable</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>cdef readonly 类型 变量名：实例属性可以被访问，但是不可以被修改</code></li>
<li><code>cdef public 类型 变量名：实例属性可以被访问，也可以被修改</code></li>
<li><code>cdef 类型 变量名：实例属性既不可以被访问，更不可以被修改</code></li>
</ul>
<p>当然定义变量无论是使用 <code>cdef public</code>还是 <code>cdef readonly</code>，Cython 内部的方法都可以实行快速访问，因为扩展类的方法基本上忽略了 readonly 和 public 的声明，它们存在的目的只是为了控制来自外界的访问。</p>
<h1 id="3、C一级的构造函数和析构函数"><a href="#3、C一级的构造函数和析构函数" class="headerlink" title="3、C一级的构造函数和析构函数"></a>3、C一级的构造函数和析构函数</h1><p>每一个实例对象都对应了一个 C 结构体，其指针就是 Python 调用<code>__init__</code>函数里面的 self 参数。当<code>__init__</code>参数被调用时，会初始化 self 参数上的属性，而且<code>__init__</code>参数是自动调用的。但是在 <code>__init__</code>参数调用之前，会先调用<code>__new__</code>方法， <code>__new__</code>方法的作用就是为创建的实例对象开辟一份内存，然后返回其指针并交给 self。在 C 级别就是，在调用<code>__init__</code>之前，实例对象指向的结构体必须已经分配好内存，并且所有结构字段都处于可以接收初始值的有效状态。</p>
<p>Cython 扩充了一个名为<code>__cinit__</code>的特殊方法，用于执行 C 级别的内存分配和初始化。不过对于之前定义的 Rectangle 类的 <code>__init__</code>方法，因为内部的字段接收的值是两个 double，不需要 C 级别的内存分配。但如果需要 C 级别的内存分配，那么就不可以使用 <code>__init__</code>了，而是需要使用 <code>__cinit__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关函数，malloc，free</span></span><br><span class="line"><span class="comment"># 如果不熟悉的话，建议去了解一下C语言</span></span><br><span class="line"><span class="keyword">from</span> libc.stdlib cimport malloc, free</span><br><span class="line"></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    cdef:</span><br><span class="line">        unsigned <span class="built_in">int</span> n</span><br><span class="line">        double *array  <span class="comment"># 一个数组，存储了double类型的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__cinit__</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="variable language_">self</span>.n = n</span><br><span class="line">        <span class="comment"># 在C一级进行动态分配内存</span></span><br><span class="line">        <span class="variable language_">self</span>.array = &lt;double *&gt;malloc(n * sizeof(double))</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.array == NULL:</span><br><span class="line">            <span class="keyword">raise</span> MemoryError()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__dealloc__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果进行了动态内存分配，也就是定义了 __cinit__，那么必须要定义 __dealloc__</span></span><br><span class="line"><span class="string">        否则在编译的时候会抛出异常：Storing unsafe C derivative of temporary Python reference</span></span><br><span class="line"><span class="string">        然后我们释放掉指针指向的内存</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.array != NULL:</span><br><span class="line">            free(<span class="variable language_">self</span>.array)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">self</span>):</span><br><span class="line">        cdef long i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n):</span><br><span class="line">            <span class="variable language_">self</span>.array[i] = (i + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">self</span>):</span><br><span class="line">        cdef long i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n):</span><br><span class="line">            <span class="built_in">print</span>(<span class="variable language_">self</span>.array[i])</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A(<span class="number">5</span>)</span><br><span class="line">a.set_value()</span><br><span class="line">a.get_value()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">2.0</span></span><br><span class="line"><span class="string">4.0</span></span><br><span class="line"><span class="string">6.0</span></span><br><span class="line"><span class="string">8.0</span></span><br><span class="line"><span class="string">10.0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>所以<code>__cinit__</code>是用来进行 C 一级内存的动态分配的，另外如果在<code>__cinit__</code>通过 malloc 进行了内存分配，那么必须要定义<code>__dealloc__</code>函数将指针指向的内存释放掉。当然即使不释放也没关系，只不过可能发生内存泄露（雾），但是<code>__dealloc__</code>这个函数是必须要被定义，它会在实例对象回收时被调用。</p>
<p>这个时候可能有人好奇了，那么 <code>__cinit__</code>和<code>__init__</code> 函数有什么区别呢？</p>
<p>首先它们只能通过 def 来定义，另外在不涉及 malloc 动态分配内存的时候， <code>__cinit__</code> 和<code>__init__</code>是等价的。然而一旦涉及到 malloc，那么动态分配内存只能在 <code>__cinit__</code>中进行，如果这个过程写在了<code>__init__</code>函数中，比如将上面例子的<code>__cinit__</code>改为 <code>__init__</code>的话，你会发现 self 的所有变量都没有设置进去、或者说设置失败，并且其它的方法若是引用了 self.array，那么还会导致丑陋的段错误。</p>
<p>还有一点就是，<code>__cinit__</code> 函数会在 <code>__init__</code>函数之前调用，实例化一个扩展类的时候，参数会先传递给 <code>__cinit__</code>，然后 <code>__cinit__</code>再将接收到的参数原封不动的传递给<code>__init__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    cdef public:</span><br><span class="line">        unsigned <span class="built_in">int</span> a, b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__cinit__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__cinit__&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.a, <span class="variable language_">self</span>.b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, c, d</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;__cinit__ 中接收两个参数</span></span><br><span class="line"><span class="string">        然后会将参数原封不动的传递到这里，所以这里也要接收两个参数</span></span><br><span class="line"><span class="string">        参数名可以不一致，但是个数要匹配</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__init__&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(c, d)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A(<span class="number">111</span>, <span class="number">222</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__cinit__</span></span><br><span class="line"><span class="string">111 222</span></span><br><span class="line"><span class="string">__init__</span></span><br><span class="line"><span class="string">111 222</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.a)  <span class="comment"># 111</span></span><br><span class="line"><span class="built_in">print</span>(a.b)  <span class="comment"># 222</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>__cinit__</code> 只有在涉及 C 级别内存分配的时候才会出现，如果没有涉及那么使用 <code>__init__</code> 就可以，虽然在不涉及 malloc 的时候这两者是等价的，但是 <code>__cinit__</code>会比 <code>__init__</code> 的开销要大一些。而如果涉及 C 级别内存分配，那么建议 <code>__cinit__</code> 只负责内存的动态分配，<code>__init__</code>负责属性的创建。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> libc.stdlib cimport malloc, free</span><br><span class="line"></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef public:</span><br><span class="line">        unsigned <span class="built_in">int</span> a, b, c</span><br><span class="line">    <span class="comment"># 这里的 array 不可以使用 public 或者 readonly</span></span><br><span class="line">    <span class="comment"># 原因很简单，因为一旦指定了 public 和 readonly，就意味着这些属性是可以被 Python 访问的</span></span><br><span class="line">    <span class="comment"># 所以需要其能够转化为 Python 中的对象，而 C 中的指针，除了 char *, 都是不能转化为 Python 对象的</span></span><br><span class="line">    <span class="comment"># 因此这里的 array 一定不能暴露给外界，否则编译出错，提示我们：double * 无法转为 Python 对象</span></span><br><span class="line">    cdef double *array</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__cinit__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 这里面只做内存分配，设置属性交给__init__</span></span><br><span class="line">        <span class="variable language_">self</span>.array = &lt;<span class="built_in">int</span> *&gt;malloc(<span class="number">3</span> * sizeof(<span class="built_in">int</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line">        <span class="variable language_">self</span>.c = c </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__dealloc__</span>(<span class="params">self</span>):</span><br><span class="line">        free(<span class="variable language_">self</span>.array)</span><br></pre></td></tr></table></figure>
<h1 id="4、cdef和cpdef方法"><a href="#4、cdef和cpdef方法" class="headerlink" title="4、cdef和cpdef方法"></a>4、cdef和cpdef方法</h1><p>之前使用了 cdef 和 cpdef，<strong>cdef 可以定义变量和函数，但是不能被 Python 直接访问；可以定义一个类，能直接被外界访问</strong>。而 cpdef 专门用于定义函数，cpdef 定义的函数既可以在 Cython 内部访问，也可以被外界访问，因为它定义了两个版本的函数：一个是高性能的纯C版本（此时等价于 cdef，至于为什么高效，因为它是 C 一级的，直接指向了具体数据结构，当然还有其它原因，），另一个是 Python 包装器（相当于手动定义的 Python 函数），所以还要求使用cpdef定义的函数的参数和返回值类型必须是 Python 可以表示的，像 char * 之外的指针就不行。</p>
<p>那么同理它们也可以作用于方法，当然方法也是实例对象在获取函数的时候进行封装得到的，所以一样的道理。但是注意：<strong>cdef 和 cpdef 修饰的 cdef class 定义的静态类里面的方法，如果是 class 定义的纯 Python 类，那么内部是不可以出现 cdef 或者 cpdef 的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef public:</span><br><span class="line">        long a, b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line">    cdef long f1(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.a * <span class="variable language_">self</span>.b</span><br><span class="line"></span><br><span class="line">    cpdef long f2(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.a * <span class="variable language_">self</span>.b</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(a.f2())  <span class="comment"># 242</span></span><br><span class="line">a.f1()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    a.f1()</span></span><br><span class="line"><span class="string">AttributeError: &#x27;cython_test.A&#x27; object has no attribute &#x27;f1&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>cdef 和 cpdef 之间在函数上的差异，在方法中得到了同样的体现。</strong></p>
<p>此外，这个类的实例也可以作为函数的参数，这个是肯定的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef public:</span><br><span class="line">        long a, b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line">    cpdef long f2(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.a * <span class="variable language_">self</span>.b</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self_lst</span>):</span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable language_">self</span> <span class="keyword">in</span> self_lst:</span><br><span class="line">        s += <span class="variable language_">self</span>.f2()</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a1 = cython_test.A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a2 = cython_test.A(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">a3 = cython_test.A(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(cython_test.func([a1, a2, a3]))  <span class="comment"># 16</span></span><br></pre></td></tr></table></figure>
<p>这是 Python 的特性，一切都是对象，尽管没有指明 self_lst 是什么类型，但只要它可以被 for 循环即可；尽管没有指明 self_lst 里面的元素是什么类型，只要它有 f2 方法即可。并且这里的 func 可以在 Cython 中定义，同样可以在 Python 中定义，这两者是没有差别的，因为都是 Python 中的函数。另外在遍历的时候仍然需要确定这个列表里面的元素是什么，意味着列表里面的元素仍然是 PyObject *，它需要获取类型、转化、属性查找，因为 Cython 不知道类型是什么、导致其无法优化。但如果规定了类型，那么再调用 f2 的时候，那么会直接指向 C 一级的数据结构，因此不需要那些无用的检测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef public:</span><br><span class="line">        long a, b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line"></span><br><span class="line">    cpdef long f2(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.a * <span class="variable language_">self</span>.b</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 规定接收一个 list，返回一个 long, 它们都是静态的，总之静态类型定义越多速度会越快</span></span><br><span class="line">cpdef long func(<span class="built_in">list</span> self_lst):</span><br><span class="line">    <span class="comment"># 声明 long 类型的 s，A 类型的 self</span></span><br><span class="line">    <span class="comment"># 我们下面使用的是 s = s + self.f2(), 所以这里的s要赋一个初始值0</span></span><br><span class="line">    cdef long s = <span class="number">0</span></span><br><span class="line">    cdef A <span class="variable language_">self</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable language_">self</span> <span class="keyword">in</span> self_lst:</span><br><span class="line">        s += <span class="variable language_">self</span>.f2()</span><br><span class="line">    <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p>调用得到的结果是一样的。这样的话速度会变快很多，因为在循环的时候，规定了变量类型，并且求和也是一个只使用 C 的操作，因为 s 是一个 double。</p>
<p>这个版本的速度比之前快了 10 倍，这表明<strong>类型化比非类型化要快了 10 倍。</strong>如果删除了 <code>cdef A self</code>，也就是不规定其类型，而还是按照 Python 的语义来调用，那么速度仍然和之前一样，即便使用 cpdef 定义。所以重点在于指定类型为静态类型，只要规定好类型，那么就可以提升速度；而 Cython 是为 Python 服务的，肯定要经常使用 Python 的类型，那么提前规定好、让其指向 C 一级的数据结构，速度会提升很多。如果是 int 和 float，那么就使用 C 中的 long 和 double，这样速度就更加快速了，当然即便用 Python 的 int 和 float 依旧可以起到加速的效果，只不过没有C明显。因此重点是一定要静态定义类型，只要类型明确那么就能进行大量的优化。</p>
<p>Python 慢有很多原因，其中一个原因就是它无法对类型进行优化，以及对象分配在堆上。无法基于类型进行优化，就意味着每次都要进行大量的检测，当然这些前面已经说过了，如果规定好类型，那么就不用兜那么大圈子了；而对象分配在堆上这是无法避免的，只要你用 Python 的对象，都是分配在堆上，所以对于整型和浮点型，通过定义为 C 的类型使其分配在栈上，能够更加的提升速度。总之记住一句话：<strong>Cython 加速的关键就在于，类型的静态声明，以及对整数和浮点使用 C 中 long 和 double。</strong></p>
<blockquote>
<p>当然，虽说如此，但是该使用 Python 中对象就使用 Python 的对象，基于类型优化其实是可以获得相当可观的速度的。至于要不要通过C的类型（比如使用结构体、共同体这种复杂类型）进行更深一步的优化，就看你对 Cython 的掌握程度了。</p>
</blockquote>
<p>在上面的基础上，如果将 cpdef 改成 cdef 那么效率会再次提升，原因很简单，因为 def 和 cpdef 都是支持外部 Python 访问的；而 cdef 只支持内部 Cython 访问，那么它就只指向了一个 C 级的数据结构，但是 def 和 cpdef 都涉及到 Python 函数，而我们说 Python 函数比 C 函数开销要大的。当然 cdef 的缺点就是外部无法访问，而且函数调用需要的开销基本可以忽略不计的。</p>
<h2 id="4-1-方法中给参数指定类型"><a href="#4-1-方法中给参数指定类型" class="headerlink" title="4.1 方法中给参数指定类型"></a>4.1 方法中给参数指定类型</h2><p>无论是 def、cdef、cpdef，都可以给参数规定类型，如果类型传递的不对就会报错。比如：上面的 func 函数如果是普通的 Python 函数，那么内部的参数对于 Python 而言只要能够被 for 循环即可，所以它可以是列表、元组、集合。但是上面的 func 规定了类型，参数只能传递 list 对象或者其子类的实例对象，如果传递 tuple 对象就会报错。</p>
<p>然后我们来看看<code>__init__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef public:</span><br><span class="line">        long a, b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">float</span> a, <span class="built_in">float</span> b</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br></pre></td></tr></table></figure>
<p>这里规定了类型，但是有没有发现什么问题呢？这里我们的参数 a 和 b 必须是一个 float，如果传递的是其它类型会报错，但是赋值的时候 self.a 和 self.b 又需要接收一个 long，所以这是一个自相矛盾的死结，在编译的时候就会报错。所以给<code>__init__</code>参数传递的值的类型要和类中 cdef 声明的类型保持一致。</p>
<p>然后为了更好地解释 Cython 带来的性能改进，需要了解关于继承、子类化、和扩展类型的多态性的基础知识。</p>
<h1 id="5、继承和子类化"><a href="#5、继承和子类化" class="headerlink" title="5、继承和子类化"></a>5、继承和子类化</h1><p>扩展类型<strong>只能继承单个基类，并且继承的基类必须是直接指向 C 实现的类型</strong>（可以是使用 cdef class 定义的扩展类型，也可以是内置类型，因为内置类型也是直接指向 C 一级的结构）。如果基类是常规的 Python 类（需要在运行时经过解释器动态解释才能指向 C 一级的结构），或者继承了多个基类，那么 Cython 在编译时会抛出异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line">    cdef public:</span><br><span class="line">        <span class="built_in">str</span> name</span><br><span class="line">        long age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    cpdef <span class="built_in">str</span> get_info(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;self.name&#125;</span>, age: <span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">CGirl</span>(<span class="title class_ inherited__">Girl</span>):</span><br><span class="line"></span><br><span class="line">    cdef public <span class="built_in">str</span> where</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, where</span>):</span><br><span class="line">        <span class="variable language_">self</span>.where = where</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyGirl</span>(<span class="title class_ inherited__">Girl</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, where</span>):</span><br><span class="line">        <span class="variable language_">self</span>.where = where</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)</span><br></pre></td></tr></table></figure>
<p>定义了一个扩展类（Girl），然后让另一个扩展类（CGirl）和普通的 Python 类（PyGirl）都去继承它。<strong>扩展类不可以继承 Python 类，但 Python 类是可以继承扩展类的</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">c_girl = cython_test.CGirl(<span class="string">&quot;cython&quot;</span>, <span class="number">17</span>, <span class="string">&quot;python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c_girl.get_info())  <span class="comment"># name: cython, age: 17</span></span><br><span class="line"></span><br><span class="line">py_girl  = cython_test.PyGirl(<span class="string">&quot;cython&quot;</span>, <span class="number">17</span>, <span class="string">&quot;python&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(py_girl .get_info())  <span class="comment"># name: cython, age: 17</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c_girl.where)  <span class="comment"># python</span></span><br><span class="line"><span class="built_in">print</span>(py_girl.where)  <span class="comment"># python</span></span><br></pre></td></tr></table></figure>
<p>对于扩展类和普通的 Python 类，它们都是可以继承扩展类的。</p>
<p>继承的话，会有什么样的结果呢？cdef定义的方法和函数一样，无法被外部的Python访问，那么内部的Python类在继承的时候可不可以访问呢？以及私有属性呢？</p>
<p>先来看看 Python 中关于私有属性的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__name = <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__name</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__foo()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line">B().test()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;B&#x27; object has no attribute &#x27;_B__name&#x27;</span></span><br><span class="line"><span class="string">&#x27;B&#x27; object has no attribute &#x27;_B__foo&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>定义的私有属性只能在当前类里面使用，一旦出去了就不能够再访问了。其实私有属性本质上只是 Python 给你改了个名字，在原来的名字前面加上一个 <code>_类名</code>，所以 <code>__name</code>和<code>__foo</code>其实相当于是 <code>_A__name</code>和 <code>_A__foo</code>。但是当在外部用实例属性去获取<code>__name</code> 和<code>__foo</code>的时候，获取的就是<code>__name</code>和<code>__foo</code>，而显然 A 里面没有这两个属性，因此报错。解决的办法就是通过调用<code>_A__name</code> 和<code>_A__foo</code>，但是不建议这么做，因为这是私有变量，如果非要访问的话，那就不要定义成私有的。如果是在 A 这个类里面调用的话，那么 Python 解释器也会自动为我们加上 <code>_类名</code> 这个前缀，在类里面调用 <code>self.__name</code>的时候，实际上调用的也是<code>self._A__name</code> 私有属性，但是在外部就不会了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> _A__name = <span class="string">&quot;cython&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = __name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是不是很神奇呢? 因为在类里面, __name 等价于 _A__name</span></span><br><span class="line"><span class="built_in">print</span>(A().name)  <span class="comment"># cython</span></span><br></pre></td></tr></table></figure>
<p>如果是继承的话，通过报错信息也知道原因。B也是一个类，那么在 B 里面调用私有属性，同样会加上 <code>_类名</code> 这个前缀，但是这个类名显然是 B 的类名，不是 A 的类名，因此找不到 <code>_B__name</code>和 <code>_B__foo</code>，当然我们强制通过<code>_A__name</code> 和<code>_A__foo</code>也是可以访问的，只是不建议这么做。</p>
<p>因此 Python 中不存在绝对的私有，只不过是解释器内部偷梁换柱将你的私有属性换了个名字罢了，但是可以认为它是私有的，因为按照原本的逻辑没有办法访问。同理继承的子类，也没有办法使用父类的私有属性。</p>
<p>但是在 Cython 中是不是这样子呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    cdef public:</span><br><span class="line">        long __age</span><br><span class="line">        <span class="built_in">str</span> __name</span><br><span class="line">        long length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, length</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__age = age</span><br><span class="line">        <span class="variable language_">self</span>.__name = name</span><br><span class="line">        <span class="variable language_">self</span>.length = length</span><br><span class="line"></span><br><span class="line">    cdef <span class="built_in">str</span> __get_info(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;self.__name&#125;</span>, age: <span class="subst">&#123;self.__age&#125;</span>, length: <span class="subst">&#123;self.length&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    cdef <span class="built_in">str</span> get_info(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name: <span class="subst">&#123;self.__name&#125;</span>, age: <span class="subst">&#123;self.__age&#125;</span>, length: <span class="subst">&#123;self.length&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">CGirl</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    cpdef test1(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.__name, <span class="variable language_">self</span>.__age, <span class="variable language_">self</span>.length)</span><br><span class="line"></span><br><span class="line">    cpdef test2(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.__get_info())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PyGirl</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.length)</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.__name, <span class="variable language_">self</span>.__age)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.__get_info())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test3</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.get_info())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cython_test</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_g = cython_test.CGirl(<span class="string">&quot;古明地觉&quot;</span>, <span class="number">17</span>, <span class="number">156</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_g.test1()</span><br><span class="line">古明地觉 <span class="number">17</span> <span class="number">156</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_g.test2()</span><br><span class="line">name: 古明地觉, age: <span class="number">17</span>, length: <span class="number">156</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>py_g = cython_test.PyGirl(<span class="string">&quot;古明地觉&quot;</span>, <span class="number">17</span>, <span class="number">156</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>py_g.test1()</span><br><span class="line"><span class="number">156</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;cython_test.pyx&quot;</span>, line <span class="number">31</span>, <span class="keyword">in</span> cython_test.PyGirl.test1</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable language_">self</span>.__name, <span class="variable language_">self</span>.__age)</span><br><span class="line">AttributeError: <span class="string">&#x27;PyGirl&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;_PyGirl__name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>py_g.test2()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;cython_test.pyx&quot;</span>, line <span class="number">34</span>, <span class="keyword">in</span> cython_test.PyGirl.test2</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable language_">self</span>.__get_info())</span><br><span class="line">AttributeError: <span class="string">&#x27;PyGirl&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;_PyGirl__get_info&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>py_g.test3()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;cython_test.pyx&quot;</span>, line <span class="number">37</span>, <span class="keyword">in</span> cython_test.PyGirl.test3</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable language_">self</span>.get_info())</span><br><span class="line">AttributeError: <span class="string">&#x27;PyGirl&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;get_info&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>看到对于 Cython 定义的 C 一级的类而言，<strong>私有属性、私有方法可以一并使用</strong>。但是对于纯 Python 类就不行了，私有属性、私有方法 无法访问就算了，就连父类使用 cdef 定义的非私有方法也无法继承下来，原因就是 PyGirl 是一个 Python 类，不是使用 cdef class 定义的静态类。如果把父类的 cdef get_info 改成 def 或者 cpdef，那么Python子类是可以直接访问的。</p>
<p>我们说 cdef 定义的是 C 一级的方法，不是 Python 的方法、也不是 cpdef 定义的时候自带 Python 包装器，因此它无法被 Python 子类继承，因此它并没有跨越语言的边界。当然如果不熟悉 Cython 中的继承、并且有很想使用继承，那么就不要使用 cdef，直接使用 cpdef 定义吧（或者使用 def，只不过此时无法指定返回值类型）。虽说 cdef 只定义的 C 一级的函数调用比自带 Python 包装器的 cpdef 快，但是说实话那一点点快几乎没啥意义。Cython 加速的核心在于类型上的优化，如果我们能使用静态的方式声明，那么速度就会有明显的提升，不要为了加速反倒畏手畏脚地这不敢用那不敢用。</p>
<p>总之 Cython 加速记住两个原则：</p>
<ul>
<li>能使用静态声明的方式使用静态声明，不仅是变量，还有参数、返回值；</li>
<li>这是 Cython 默认的行为，int 和 float 使用的是 C 中 的int 和 float，但是为了支持更大的数字，我们直接使用 long 和 double 即可。</li>
</ul>
<p>但是问题来了，如果希望自定义的扩展类不可以被其它类继承的话该怎么做呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cimport cython</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 cython.final 进行装饰，那么这个类就不可被继承了</span></span><br><span class="line"><span class="meta">@cython.final</span></span><br><span class="line">cdef <span class="keyword">class</span> <span class="title class_">NotInheritable</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>通过 cython.final，那么被装饰的类就是一个不可继承类，不光是外界普通的 Python 类，内部的扩展类也是不可继承的。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(cython_test.NotInheritable):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">TypeError: type &#x27;cython_test.NotInheritable&#x27; is not an acceptable base type</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>告诉我们 NotInheritable 不是一个合法的基类。</p>
<h1 id="6、类型转换"><a href="#6、类型转换" class="headerlink" title="6、类型转换"></a>6、类型转换</h1><p>Python 中类在继承扩展类的时候，无法继承其内部的 cdef 方法，但如果这个类是继承扩展类的，那么其实例对象可不可以转化为扩展类的类型呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef funcA(<span class="variable language_">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="comment"># 显然 func1 内部无法访问扩展类A的funcA</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.funcA()</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># 但是我们在使用的时候将其类型转化一下</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (&lt;A&gt; <span class="variable language_">self</span>).funcA()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cython_test</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = cython_test.B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.func1()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;cython_test.pyx&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> cython_test.B.func1</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>.funcA()</span><br><span class="line">AttributeError: <span class="string">&#x27;B&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;funcA&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.func2()</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>看到 b.func2 是可以调用成功的，但知道使用 <code>&lt;&gt;</code> 这种方式如果转化不成功，那么也不会有任何影响，会保留原来值（C中的整型和浮点除外），这可能会有点危险。因此<strong>可以通过 <code>(&lt;A?&gt; self)</code>，这样 self 必须是 A 或者其子类的实例对象</strong>，否则报错。</p>
<h1 id="7、扩展类型对象和None"><a href="#7、扩展类型对象和None" class="headerlink" title="7、扩展类型对象和None"></a>7、扩展类型对象和None</h1><p>看一个简单的函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line">    cdef public:</span><br><span class="line">        <span class="built_in">str</span> name</span><br><span class="line">        long age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">cpdef <span class="built_in">tuple</span> dispatch(Girl g):</span><br><span class="line">    <span class="keyword">return</span> g.name, g.age</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cython_test.dispatch(cython_test.Girl(<span class="string">&quot;python&quot;</span>, <span class="number">17</span>)))  <span class="comment"># (&#x27;python&#x27;, 17)</span></span><br><span class="line"><span class="built_in">print</span>(cython_test.dispatch(cython_test.Girl(<span class="string">&quot;cython&quot;</span>, <span class="number">16</span>)))  <span class="comment"># (&#x27;cython&#x27;, 16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(cython_test.Girl):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cython_test.dispatch(B(<span class="string">&quot;mashiro&quot;</span>, <span class="number">16</span>)))  <span class="comment"># (&#x27;mashiro&#x27;, 16)</span></span><br><span class="line"></span><br><span class="line">cython_test.dispatch(<span class="built_in">object</span>())</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    cython_test.dispatch(object())</span></span><br><span class="line"><span class="string">TypeError: Argument &#x27;g&#x27; has incorrect type (expected cython_test.Girl, got object)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>传递一个 Girl 或者其子类的实例对象的话是没有问题的，但是传递一个其它的则不行。</p>
<p>但是在 Cython 中 None 是一个例外，即使它不是 Girl 的实例对象，但也是可以传递的，除了 C 规定的类型之外，只要是 Python 的类型，不管什么，传递一个 None 都是可以的。这就类似于 C 中的空指针，任何指针都可以传递给空指针，但是没有办法做什么操作。</p>
<p>所以这里可以传递一个 None，但是执行逻辑的时候显然会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line">cython_test.dispatch(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>然而报错还是轻的，上面代码执行的时候会发生段错误，解释器直接异常退出了。原因就在于不安全地访问了 Girl 实例对象的成员属性，属性和方法都是 C 接口的一部分，而 Python 中 None 本质上没有 C 接口，因此访问属性或者调用方法都是无效的。为了确保这些操作的安全，最好加上一层检测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpdef <span class="built_in">tuple</span> dispatch(Girl g):</span><br><span class="line">    <span class="keyword">if</span> g <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> g.name, g.age</span><br></pre></td></tr></table></figure>
<p>但是除了上面那种做法，Cython 还提供了一种特殊的语法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">Girl g <span class="keyword">not</span> <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">return</span> g.name, g.age</span><br></pre></td></tr></table></figure>
<p>此时如果我们传递了 None，那么就会报错。不过这个版本由于要预先进行类型检查，判断是否为 None，从而会牺牲一些效率。不过虽说如此，但是传递 None 所造成的段错误是非常致命的，因此非常有必要防范这一点的。当然还是那句话，虽然效率会牺牲一点点，但还是那句话，与 Cython 带来的效率提升相比，这点牺牲是非常小的，况且这也是必要的。但是注意：<strong>not None 只能出现在 def 定义的函数中，cdef 和 cpdef 是不合法的</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line">cython_test.dispatch(<span class="literal">None</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    cython_test.dispatch(None)</span></span><br><span class="line"><span class="string">TypeError: Argument &#x27;g&#x27; has incorrect type (expected cython_test.Girl, got NoneType)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>此时对 None 也是一视同仁的，传递一个 None 也是不符合类型的。这里我们设置的是 not None，但是除了 None 还能设置别的吗？答案是不行的，只能设置 None，因为 Cython 只有对 None 不会进行检测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> cpdef <span class="built_in">tuple</span> dispatch(Girl g <span class="keyword">not</span> <span class="number">123</span>):</span><br><span class="line">                       ^</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">cython_test.pyx:<span class="number">11</span>:<span class="number">24</span>: Expected <span class="string">&#x27;None&#x27;</span></span><br></pre></td></tr></table></figure>
<p>许多人认为需要 not None 字句是不方便的，这个特性经常被争论，但幸运的是，在函数的参数声明中使用 not None 是非常方便的。</p>
<p>为了更高的性能，Cython 还提供了一个默认的 nonecheck 编译器指令，可以对整个扩展模块不进行检查，通过在文件的开头加上一个注释：<code># cython: nonecheck=True</code>。</p>
<h1 id="8、Cython中扩展类的property"><a href="#8、Cython中扩展类的property" class="headerlink" title="8、Cython中扩展类的property"></a>8、Cython中扩展类的property</h1><p>Python 中的 property 非常的易用且强大，可以精确地控制某个属性的修改，而 Cython 也是支持 property 描述符的，但是方式有些不一样。不过在介绍 Cython 的 property 之前，来看看 Python 中的 property。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 不需要我们对x进行调用，直接通过self.x即可获取返回值</span></span><br><span class="line">        <span class="comment"># 让函数像属性一样直接获取</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="comment"># 当我们self.x = &quot;cython&quot;的时候，会调用这个函数</span></span><br><span class="line">        <span class="comment"># &quot;cython&quot;就会传递给这里的value</span></span><br><span class="line">        <span class="variable language_">self</span>.name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 执行del self.x的时候，就会调用这个函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;被调用了&quot;</span>)</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="built_in">print</span>(girl.x)  <span class="comment"># None</span></span><br><span class="line">girl.x = <span class="string">&quot;cython&quot;</span></span><br><span class="line"><span class="built_in">print</span>(girl.x)  <span class="comment"># cython</span></span><br><span class="line"><span class="keyword">del</span> girl.x  <span class="comment"># 被调用了</span></span><br></pre></td></tr></table></figure>
<p>这里是通过装饰器的方式实现的，三个函数都是一样的名字，除了使用装饰器，还可以这么做。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fget</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fset</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fdel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;被调用了&quot;</span>)</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 传递三个函数即可，除此之外还有一个doc属性</span></span><br><span class="line">    x = <span class="built_in">property</span>(fget, fset, fdel, doc=<span class="string">&quot;这是property&quot;</span>)</span><br><span class="line"></span><br><span class="line">girl = Girl()</span><br><span class="line"><span class="built_in">print</span>(girl.x)  <span class="comment"># None</span></span><br><span class="line">girl.x = <span class="string">&quot;cython&quot;</span></span><br><span class="line"><span class="built_in">print</span>(girl.x)  <span class="comment"># cython</span></span><br><span class="line"><span class="keyword">del</span> girl.x  <span class="comment"># 被调用了</span></span><br></pre></td></tr></table></figure>
<p>所以 property 就是像访问属性一样访问函数，那么它内部是怎么做到的呢？不用想，肯定是通过描述符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyProperty</span>:  <span class="comment"># 模仿类property，实现与其一样的功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.fget = fget</span><br><span class="line">        <span class="variable language_">self</span>.fset = fset</span><br><span class="line">        <span class="variable language_">self</span>.fdel = fdel</span><br><span class="line">        <span class="variable language_">self</span>.doc = doc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fget(instance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fset(instance, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, instance</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fdel(instance)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setter</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(<span class="variable language_">self</span>)(<span class="variable language_">self</span>.fget, func, <span class="variable language_">self</span>.fdel, <span class="variable language_">self</span>.doc)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleter</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(<span class="variable language_">self</span>)(<span class="variable language_">self</span>.fget, <span class="variable language_">self</span>.fset, func, <span class="variable language_">self</span>.doc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl1</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @MyProperty</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;被调用了&quot;</span>)</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl2</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fget</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fset</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fdel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;被调用了&quot;</span>)</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line">    x = MyProperty(fget, fset, fdel)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">girl1 = Girl1()</span><br><span class="line"><span class="built_in">print</span>(girl1.x)  <span class="comment"># None</span></span><br><span class="line">girl1.x = <span class="string">&quot;cython&quot;</span></span><br><span class="line"><span class="built_in">print</span>(girl1.x)  <span class="comment"># cython</span></span><br><span class="line"><span class="keyword">del</span> girl1.x  <span class="comment"># 被调用了</span></span><br><span class="line"></span><br><span class="line">girl2 = Girl2()</span><br><span class="line"><span class="built_in">print</span>(girl2.x)  <span class="comment"># None</span></span><br><span class="line">girl2.x = <span class="string">&quot;cython&quot;</span></span><br><span class="line"><span class="built_in">print</span>(girl2.x)  <span class="comment"># cython</span></span><br><span class="line"><span class="keyword">del</span> girl2.x  <span class="comment"># 被调用了</span></span><br></pre></td></tr></table></figure>
<p>通过描述符的方式手动实现了一个 property 的功能，描述符事实上在 Python 解释器的层面也用的非常多，实例调用方法的时候，第一个参数 self 会自动传递也是通过描述符实现的。所以描述符不光在 Python 的层面用，在解释器的层面上也大量使用描述符。同理字典也是如此，定义的类的实例对象的属性都是存在一个字典里面的，称之为属性字典，所以字典在 Python 中是经过高度优化的，原因就是不仅我们在用，底层也在大量使用。</p>
<p>下面来看看Cython中的property</p>
<p>针对扩展类的 property，Cython 有着不同的语法，但是实现了相同的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line">    cdef <span class="built_in">str</span> name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">property</span> x:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, value</span>):</span><br><span class="line">            <span class="variable language_">self</span>.name = value</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">g = cython_test.Girl()</span><br><span class="line"><span class="built_in">print</span>(g.x)  <span class="comment"># None</span></span><br><span class="line">g.x = <span class="string">&quot;cython&quot;</span></span><br><span class="line"><span class="built_in">print</span>(g.x)  <span class="comment"># cython</span></span><br></pre></td></tr></table></figure>
<p>看到 Cython 是将 property 和描述符结合在一起了，但是实现起来感觉更方便了。</p>
<p>不过最重要的还是魔法方法，魔法方法算是 Python 中非常强大的一个特性， Python 将每一个操作符都抽象成了对应的魔法方法，也正因为如此 numpy 也得以很好的实现。那么在 Cython 中，魔法方法是如何体现的呢？</p>
<h1 id="9、魔法方法在Cython中使用"><a href="#9、魔法方法在Cython中使用" class="headerlink" title="9、魔法方法在Cython中使用"></a>9、魔法方法在Cython中使用</h1><p>通过魔法方法可以对运算符进行重载，魔法方法的特点就是它的函数名<strong>以双下划线开头、并以双下划线结尾</strong>。之前讨论了<code>__cinit__</code>、<code>__init__</code>、<code>__dealloc__</code>，并了解了它们分别用于 C 一级的初始化、Python 一级的初始化、对象的释放（特指 C 中的指针）。除了那三个，Cython 中也支持其它的魔法方法，但是注意：Cython 不支持 <code>__del__</code>，<code>__del__</code>由 <code>__dealloc__</code>负责实现。</p>
<h2 id="9-1-算术魔法方法"><a href="#9-1-算术魔法方法" class="headerlink" title="9.1 算术魔法方法"></a>9.1 算术魔法方法</h2><p>假设在 Python 中定义了一个类 class A，如果希望 A 的实例对象可以进行加法运算，那么内部需要定义<code>__add__</code> 或<code>__radd__</code>方法。关于<code>__add__</code>和<code>__radd__</code>的区别就在于该实例对象是在加号的左边还是右边。以 <code>A() + B()</code> 为例，A 和 B 是我们自定义的类：</p>
<ul>
<li><code>首先尝试寻找 A 的 __add__ 方法, 如果有直接调用</code></li>
<li><code>如果 A 中不存在 __add__ 方法, 那么会去寻找 B 的 __radd__ 方法</code></li>
</ul>
<p>但如果是一个整数和自定义的类的实例对象相加呢？</p>
<ul>
<li><code>123 + A(): 先寻找 A 的 __radd__</code></li>
<li><code>A() + 123: 先寻找 A 的 __add__</code></li>
</ul>
<p>代码演示一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A add&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A radd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B add&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B radd&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A() + B())  <span class="comment"># A add</span></span><br><span class="line"><span class="built_in">print</span>(B() + A())  <span class="comment"># B add</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span> + B())  <span class="comment"># B radd</span></span><br><span class="line"><span class="built_in">print</span>(A() + <span class="number">123</span>)  <span class="comment"># A add</span></span><br></pre></td></tr></table></figure>
<p>除了类似于 <code>__add__</code>这种实例对象放在左边、<code>__radd__</code>这种实例对象放在右边，还有<code>__iadd__</code>，它用于 += 这种形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iadd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__iadd__ is called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + other</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a += <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__iadd__ is called</span></span><br><span class="line"><span class="string">124</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 如果没定义__iadd__，也是可以使用这种形式，会转化成a = a + 123，所以会调用__add__方法</span></span><br></pre></td></tr></table></figure>
<p>当然这都比较简单，其它的算数魔法方法也是类似的。并且里面的 self 就是对应类的实例对象，有人会觉得这不是废话吗？之所以要提这一点，是为了给下面的Cython做铺垫。</p>
<p>对于 Cython 中的扩展类来说，不使用类似于 <code>__radd__</code>这种实现方式，只需要定义一个 <code>__add__</code>即可同时实现 <code>__add__</code> 和 <code>__radd__</code>。对于 Cython 中的扩展类型 A，a 是 A 的实例对象，如果是 a + 123，那么会调用 <code>__add__</code>方法，然后第一个参数是 a、第二个参数是123；但如果是 123 + a，那么依旧会调用<code>__add__</code>，不过此时 <code>__add__</code>的第一个参数是 123、第二个参数才是 a。所以不像 Python 中的魔法方法，第一个参数 self 永远是实例本身，第一个参数是谁取决于谁在前面。所以将第一个参数叫做 self 容易产生误解，官方也不建议将第一个参数使用 self 作为参数名。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">g = cython_test.Girl()</span><br><span class="line"><span class="built_in">print</span>(g + <span class="number">123</span>)  <span class="comment"># (&lt;cython_test.Girl object at 0x0000028752477940&gt;, 123)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span> + g)  <span class="comment"># (123, &lt;cython_test.Girl object at 0x0000028752477940&gt;)</span></span><br></pre></td></tr></table></figure>
<p>我们看到，<code>__add__</code>中的参数确实是由位置决定的，那么再来看一个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">Girl</span>:</span><br><span class="line">    cdef long a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, Girl):</span><br><span class="line">            <span class="comment"># 这里为什么需要转化呢？直接 x.a + y 不行吗？</span></span><br><span class="line">            <span class="comment"># 答案是不行的，因为这个 x 是我们外部传过来的 Girl 对象</span></span><br><span class="line">            <span class="comment"># 但是我们这里的 a 不是一个 public 或者 readonly，直接访问是得不到的，所以需要转化一下才可以访问</span></span><br><span class="line">            <span class="keyword">return</span> (&lt;Girl&gt; x).a + y</span><br><span class="line">        <span class="keyword">return</span> (&lt;Girl&gt; y).a + x</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">g = cython_test.Girl(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(g + <span class="number">2</span>)  <span class="comment"># 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> + g)  <span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和浮点数运算也是可以的</span></span><br><span class="line"><span class="built_in">print</span>(g + <span class="number">2.1</span>)  <span class="comment"># 5.1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2.1</span> + g)  <span class="comment"># 5.1</span></span><br><span class="line"></span><br><span class="line">g += <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(g)  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
<p>除了 <code>__add__</code>，Cython 也是支持<code>__iadd__</code> 的，此时的第一个参数是 self，因为 += 这种形式，第一种参数永远是实例对象。</p>
<h2 id="9-2-富比较"><a href="#9-2-富比较" class="headerlink" title="9.2 富比较"></a>9.2 富比较</h2><p>Cython 的扩展类可以使用<code>__eq</code>、<code>__ne__</code>等等，和 Python 一致的富比较魔法方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="comment"># 这里比较操作符两边的值的位置依旧会影响这里的x、y</span></span><br><span class="line">    <span class="comment"># 但是对于Python中的比较来说则不会，self永远是实例对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>, other)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;==&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A()</span><br><span class="line"><span class="built_in">print</span>(a == <span class="number">3</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.A object at 0x0000015D792C7940&gt; 3</span></span><br><span class="line"><span class="string">==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> == a)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.A object at 0x0000015D792C7940&gt; 3</span></span><br><span class="line"><span class="string">==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>和算术魔法方法不一样，比较操作没有<code>__req__</code>或者<code>__ieq</code>__，并且比较的时候第一个参数永远是实例对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>, other)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A ==&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>, other)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;B ==&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A()</span><br><span class="line">b = cython_test.B()</span><br><span class="line"><span class="comment"># 调用 a 的 __eq__</span></span><br><span class="line"><span class="built_in">print</span>(a == <span class="number">123</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.A object at 0x00000223641631C0&gt; 123</span></span><br><span class="line"><span class="string">A ==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 调用 b 的 __eq__</span></span><br><span class="line"><span class="built_in">print</span>(b == <span class="number">123</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.B object at 0x00000223641E71F0&gt; 123</span></span><br><span class="line"><span class="string">B ==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 调用 a 的 __eq__, 第一个参数还是 a</span></span><br><span class="line"><span class="built_in">print</span>(a == <span class="number">123</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.A object at 0x00000223641631C0&gt; 123</span></span><br><span class="line"><span class="string">A ==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 调用 b 的 __eq__, 第一个参数还是 b</span></span><br><span class="line"><span class="built_in">print</span>(b == <span class="number">123</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.B object at 0x00000223641E71F0&gt; 123</span></span><br><span class="line"><span class="string">B ==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 调用 a 的 __eq__, 第一个参数是 a, 第二个参数是 b</span></span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.A object at 0x00000223641631C0&gt; &lt;cython_test.B object at 0x00000223641E71F0&gt;</span></span><br><span class="line"><span class="string">A ==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 调用 b 的 __eq__, 第一个参数是 b, 第二个参数是 a</span></span><br><span class="line"><span class="built_in">print</span>(b == a)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.B object at 0x00000223641E71F0&gt; &lt;cython_test.A object at 0x00000223641631C0&gt;</span></span><br><span class="line"><span class="string">B ==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>链式比较也是可以的，比如：a == b == 123 等价于 a == b and b == 123。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A()</span><br><span class="line">b = cython_test.B()</span><br><span class="line"><span class="built_in">print</span>(a == b == <span class="number">123</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;cython_test.A object at 0x000001817F1D31C0&gt; &lt;cython_test.B object at 0x000001817630E0D0&gt;</span></span><br><span class="line"><span class="string">&lt;cython_test.B object at 0x000001817630E0D0&gt; 123</span></span><br><span class="line"><span class="string">B ==</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>先执行 a == b 返回 “A ==”，再执行 b == 3 返回 “B ==”，然后 “A ==” 和 “B ==” 进行 and，前面为真，所以返回后面的 “B ==”。</p>
<h2 id="9-3-迭代器支持"><a href="#9-3-迭代器支持" class="headerlink" title="9.3 迭代器支持"></a>9.3 迭代器支持</h2><p>Cython 中的扩展类也是支持迭代器协议的，而且定义的方法和纯 Python 之间是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef public:</span><br><span class="line">        <span class="built_in">list</span> values</span><br><span class="line">        long __index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, values</span>):</span><br><span class="line">        <span class="variable language_">self</span>.values = values</span><br><span class="line">        <span class="variable language_">self</span>.__index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ret = <span class="variable language_">self</span>.values[<span class="variable language_">self</span>.__index]</span><br><span class="line">            <span class="variable language_">self</span>.__index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"> <span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A([<span class="string">&#x27;椎名真白&#x27;</span>, <span class="string">&#x27;古明地觉&#x27;</span>, <span class="string">&#x27;雾雨魔理沙&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">椎名真白</span></span><br><span class="line"><span class="string">古明地觉</span></span><br><span class="line"><span class="string">雾雨魔理沙</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>知道在 Python 中，for 循环会先去寻找<code>__iter__</code>，但如果找不到会退而求其次去找 <code>__getitem__</code>，那么在 Cython 中是不是也是如此呢。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cdef <span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line"></span><br><span class="line">    cdef public:</span><br><span class="line">        <span class="built_in">list</span> values</span><br><span class="line">        long __index</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, values</span>):</span><br><span class="line">        <span class="variable language_">self</span>.values = values</span><br><span class="line">        <span class="variable language_">self</span>.__index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.values[item]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A([<span class="string">&#x27;椎名真白&#x27;</span>, <span class="string">&#x27;古明地觉&#x27;</span>, <span class="string">&#x27;雾雨魔理沙&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(_)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">椎名真白</span></span><br><span class="line"><span class="string">古明地觉</span></span><br><span class="line"><span class="string">雾雨魔理沙</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们看到，也是一样的。</p>
<p>当然上面只是介绍了魔法方法的一部分，Python 中的魔法方法（比如<code>__getattr__</code>、<code>__call__</code>、<code>__hash__</code>等等）在 Cython 中基本上都支持，并且 Cython 还提供了一些 Python 所没有的魔法方法。当然这些我们就不说了，如果你熟悉 Python 的话，那么在 Cython 中也是按照相同的方式进行使用即可。总之，用久了就孰能生巧了。</p>
<blockquote>
<p><strong>注意</strong>：魔法方法只能用def定义，不可以使用cdef或者cpdef。</p>
</blockquote>
<p>还有上下文管理器，在Cython中也是一样的用法。Python中基本上所有的魔法方法在Cython都可以直接用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mport pyximport</span><br><span class="line">pyximport.install(language_level=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cython_test</span><br><span class="line"></span><br><span class="line">a = cython_test.A()</span><br><span class="line"><span class="keyword">with</span> a:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">__enter__</span></span><br><span class="line"><span class="string">__exit__</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>Cython 中的扩展类，它和 Python 中内置类是等价的，都是直接指向了 C 一级的数据结构，不需要字节码的翻译过程。也正因为如此，它失去一些动态特性，但同时也获得了效率，因为这两者本来就是不可兼得的。</p>
<p>Cython 的类有点复杂，还是需要多使用，不过它毕竟在各方面都和 Python 保持接近，因此学习来也不是那么费劲。</p>
<p>虽然创建扩展类的最简单的方式是通过 Cython，但是通过 Python/C API 直接在 C 中实现的话，则是最有用的练习，但还是那句话，它需要我们对 Python/C API 有一个很深的了解，而这是一个非常难得的事情，因此使用 Cython 就变成了我们最佳的选择。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://wdndev.github.io">Firefly</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wdndev.github.io/program_language/cython/4.Cython%E4%B8%AD%E6%89%A9%E5%B1%95%E7%B1%BB/">https://wdndev.github.io/program_language/cython/4.Cython中扩展类/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PL/">PL</a></div><div class="post_share"><div class="social-share" data-image="/img/wdn_icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/program_language/pl_idx/" title="编程语言 (Programming Language)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-07</div><div class="title">编程语言 (Programming Language)</div></div></a></div><div><a href="/program_language/cython/1.Cython%E6%A6%82%E8%BF%B0/" title="1.Cython概述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-20</div><div class="title">1.Cython概述</div></div></a></div><div><a href="/program_language/cython/2.Cython%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/" title="2.Cython编译运行"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-20</div><div class="title">2.Cython编译运行</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81Python%E7%B1%BB%E5%92%8C%E6%89%A9%E5%B1%95%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">1、Python类和扩展类之间的差异</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81Cython%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E7%B1%BB"><span class="toc-text">2、Cython中的扩展类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81C%E4%B8%80%E7%BA%A7%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">3、C一级的构造函数和析构函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81cdef%E5%92%8Ccpdef%E6%96%B9%E6%B3%95"><span class="toc-text">4、cdef和cpdef方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%BB%99%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.1 方法中给参数指定类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AD%90%E7%B1%BB%E5%8C%96"><span class="toc-text">5、继承和子类化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">6、类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8CNone"><span class="toc-text">7、扩展类型对象和None</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81Cython%E4%B8%AD%E6%89%A9%E5%B1%95%E7%B1%BB%E7%9A%84property"><span class="toc-text">8、Cython中扩展类的property</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E5%9C%A8Cython%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-text">9、魔法方法在Cython中使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E7%AE%97%E6%9C%AF%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95"><span class="toc-text">9.1 算术魔法方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%AF%8C%E6%AF%94%E8%BE%83"><span class="toc-text">9.2 富比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%94%AF%E6%8C%81"><span class="toc-text">9.3 迭代器支持</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2026 By Firefly</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">簡</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'oe7vzWxH80qwJJjWslYTCViT-gzGzoHsz',
      appKey: 'k89nSbK0BTbmzmpQottRHvNI',
      avatar: 'monsterid',
      serverURLs: 'https://oe7vzwxh.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async src="/js/title.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":180,"height":360,"hOffset":0,"vOffset":-100},"mobile":{"show":true},"react":{"opacity":0.85},"log":false});</script></body></html>