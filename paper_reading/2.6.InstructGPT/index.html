<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>论文精读 InstructGPT | 37.2° Blog</title><meta name="author" content="Firefly"><meta name="copyright" content="Firefly"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="6.InstructGPTChatGPT  Chat GPT 既没有发表在 NeurlPS 上面，也没有发表在 EMNLP ，甚至连一篇论文都没有 InstructGPT是微调的GPT-3.5模型  0.前言ChatGPT0.1 ChatGPT 的四个应用官方给出四个使用的场景 1、ChatGPT asks the clarifying questions to debug code  2、Cha">
<meta property="og:type" content="article">
<meta property="og:title" content="论文精读 InstructGPT">
<meta property="og:url" content="https://wdndev.github.io/paper_reading/2.6.InstructGPT/index.html">
<meta property="og:site_name" content="37.2° Blog">
<meta property="og:description" content="6.InstructGPTChatGPT  Chat GPT 既没有发表在 NeurlPS 上面，也没有发表在 EMNLP ，甚至连一篇论文都没有 InstructGPT是微调的GPT-3.5模型  0.前言ChatGPT0.1 ChatGPT 的四个应用官方给出四个使用的场景 1、ChatGPT asks the clarifying questions to debug code  2、Cha">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wdndev.github.io/img/wdn_icon.png">
<meta property="article:published_time" content="2023-07-02T16:00:00.000Z">
<meta property="article:modified_time" content="2025-11-01T23:46:10.731Z">
<meta property="article:author" content="Firefly">
<meta property="article:tag" content="Transformer">
<meta property="article:tag" content="PaperReading">
<meta property="article:tag" content="GPT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wdndev.github.io/img/wdn_icon.png"><link rel="shortcut icon" href="/img/wdn_icon.png"><link rel="canonical" href="https://wdndev.github.io/paper_reading/2.6.InstructGPT/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search/.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":100,"languages":{"author":"Author: Firefly","link":"Link: ","source":"Source: 37.2° Blog","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '论文精读 InstructGPT',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-02 07:46:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/wdn_icon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">565</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Content</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/paper_reading/pr_content"><i class="fa-fw fas fa-newspaper"></i><span> Paper</span></a></li><li><a class="site-page child" href="/llms/llms_idx"><i class="fa-fw fa-regular fa-bookmark"></i><span> LLMs</span></a></li><li><a class="site-page child" href="/jupyter"><i class="fa-fw fa-solid fa-file"></i><span> Jupyter</span></a></li><li><a class="site-page child" href="/dsa/dsa_idx"><i class="fa-fw fas fa-tree"></i><span> Algorithm</span></a></li><li><a class="site-page child" href="/program_language/pl_idx"><i class="fa-fw fas fa-code"></i><span> PLs</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-calendar-days"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/daily/github/index"><i class="fa-fw fas fa-arrow-trend-up"></i><span> Github</span></a></li><li><a class="site-page child" href="/daily/weibo/index"><i class="fa-fw fas fa-brands fa-weibo"></i><span> Weibo</span></a></li><li><a class="site-page child" href="/daily/hf/index"><i class="fa-fw fas fa-face-smile"></i><span> HF</span></a></li><li><a class="site-page child" href="/daily/domain/index"><i class="fa-fw fas fa-book-open"></i><span> Arxiv</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="37.2° Blog"><span class="site-name">37.2° Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Content</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/paper_reading/pr_content"><i class="fa-fw fas fa-newspaper"></i><span> Paper</span></a></li><li><a class="site-page child" href="/llms/llms_idx"><i class="fa-fw fa-regular fa-bookmark"></i><span> LLMs</span></a></li><li><a class="site-page child" href="/jupyter"><i class="fa-fw fa-solid fa-file"></i><span> Jupyter</span></a></li><li><a class="site-page child" href="/dsa/dsa_idx"><i class="fa-fw fas fa-tree"></i><span> Algorithm</span></a></li><li><a class="site-page child" href="/program_language/pl_idx"><i class="fa-fw fas fa-code"></i><span> PLs</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-calendar-days"></i><span> Daily</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/daily/github/index"><i class="fa-fw fas fa-arrow-trend-up"></i><span> Github</span></a></li><li><a class="site-page child" href="/daily/weibo/index"><i class="fa-fw fas fa-brands fa-weibo"></i><span> Weibo</span></a></li><li><a class="site-page child" href="/daily/hf/index"><i class="fa-fw fas fa-face-smile"></i><span> HF</span></a></li><li><a class="site-page child" href="/daily/domain/index"><i class="fa-fw fas fa-book-open"></i><span> Arxiv</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">论文精读 InstructGPT</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-02T16:00:00.000Z" title="Created 2023-07-03 00:00:00">2023-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-11-01T23:46:10.731Z" title="Updated 2025-11-02 07:46:10">2025-11-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PaperReading/">PaperReading</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>34min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="论文精读 InstructGPT"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="6-InstructGPT"><a href="#6-InstructGPT" class="headerlink" title="6.InstructGPT"></a>6.InstructGPT</h1><p><strong>ChatGPT</strong></p>
<ul>
<li>Chat GPT 既没有发表在 NeurlPS 上面，也没有发表在 EMNLP ，甚至连一篇论文都没有</li>
<li>InstructGPT是微调的GPT-3.5模型</li>
</ul>
<h1 id="0-前言ChatGPT"><a href="#0-前言ChatGPT" class="headerlink" title="0.前言ChatGPT"></a>0.前言ChatGPT</h1><h2 id="0-1-ChatGPT-的四个应用"><a href="#0-1-ChatGPT-的四个应用" class="headerlink" title="0.1 ChatGPT 的四个应用"></a>0.1 <strong>ChatGPT 的四个应用</strong></h2><p><strong>官方</strong>给出四个使用的场景</p>
<p><strong>1、ChatGPT asks the clarifying questions to debug code</strong></p>
<p><img src="https://i0.hdslb.com/bfs/note/ed69197fc78382b5d08657a075377980f5ff6432.png@690w_!web-note.webp" alt=""></p>
<p><strong>2、ChatGPT initially refuses to answer a question that could be about illegal activities but responds after the user clarifies their intent</strong></p>
<ul>
<li>ChatGPT 能在<strong>安全性</strong>上避免进行一些非法的回答</li>
</ul>
<p><img src="https://i0.hdslb.com/bfs/note/3c51e62e1a2efe82d4ed35ff83544dc734e61a77.png@690w_!web-note.webp" alt=""></p>
<p><strong>3、ChatGPT is able to understand the reference (“it”) to the subject of the previous question (“fermat’s little theorem”)</strong></p>
<ul>
<li>ChatGPT 是能够理解上下文的，它能够记住之前的问题（它能够做一个 <strong>8000 词</strong>的上下文，也就是说如果回答是在 8000 词以内的话是能够联系上下文的）</li>
</ul>
<p><img src="https://i0.hdslb.com/bfs/note/ac04884a9e9c9f0b19e7a57df1f0e6a72ec87b8e.png@690w_!web-note.webp" alt=""></p>
<p><strong>4、ChatGPT provides responses to follow-up instructions</strong></p>
<ul>
<li>ChatGPT 是能够理解自己的<strong>局限性</strong>的，它明白自己有哪些事情是自己做不到的</li>
</ul>
<p><img src="https://i0.hdslb.com/bfs/note/1478eb9585a75dd1660127990c4f8f4ec8d53162.png@690w_!web-note.webp" alt=""></p>
<p>以上是官方给出的应用样例，还有一些其他的应用：</p>
<ul>
<li>把它伪装成一个操作系统，让它来执行代码</li>
</ul>
<p>GPT-3发布之后的一两年之内，出现了上百种应用，和 GPT-3 相比，ChatGPT 是基于<strong>对话</strong>的形式，而且是多轮对话，ChatGPT 更加自然一点，符合人的交互习惯，所以不出意外的话，未来也会出现越来越多的应用。</p>
<p>（根据 OpenAI 的一贯作风，它会先发布模型，过几个月之后再发论文，目前只有模型和博客，论文暂时还没有发布）</p>
<h2 id="0-2-ChatGPT-Methods"><a href="#0-2-ChatGPT-Methods" class="headerlink" title="0.2 ChatGPT Methods"></a>0.2 ChatGPT <strong>Methods</strong></h2><p>ChatGPT 用的是跟 InstructGPT 相同的方法</p>
<ul>
<li>InstructGPT 其实跟 GPT123 更相近，它的数据格式是一个 prompt</li>
<li>ChatGPT 的输入是一个对话的形式，所以说<strong>在数据收集上面和 InstructGPT 有一点不同</strong>：在标注数据的时候需要做成<strong>多轮对话</strong>的形式</li>
</ul>
<p><img src="https://i0.hdslb.com/bfs/note/9fe1a809c927f38ef6fd450c13c8cd5375286663.png@690w_!web-note.webp" alt=""></p>
<p>（这张图和 Instruct GPT 也是相同的）</p>
<p>ChatGPT 是在 GPT3.5系列的基础上进行微调得来的，这里的 GPT3.5 应该就是在GPT-3 代码的基础上进行修改得到的</p>
<h2 id="0-3-InstructGPT"><a href="#0-3-InstructGPT" class="headerlink" title="0.3 InstructGPT"></a>0.3 <strong>InstructGPT</strong></h2><ul>
<li>OpenAI 的工作都是基于前面的工作，工作是具有<strong>连续性</strong>的</li>
<li>InstructGPT 这篇文章发表于 <strong>2022 年 3 月 4 日</strong></li>
<li>论文标题：Training language models to follow instructions with human feedback</li>
<li>论文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2203.02155" title="https://arxiv.org/abs/2203.02155"><strong>https://arxiv.org/abs/2203.02155</strong></a></li>
</ul>
<p>其他参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://openai.com/blog/chatgpt/" title="https://openai.com/blog/chatgpt/">https://openai.com/blog/chatgpt/</a></li>
<li>统计学中的信噪比怎么理解，<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37522785" title="https://www.zhihu.com/question/37522785">https://www.zhihu.com/question/37522785</a></li>
</ul>
<h1 id="1-标题、作者"><a href="#1-标题、作者" class="headerlink" title="1.标题、作者"></a>1.标题、作者</h1><p>Training language models to follow instructions with human feedback（训练语言模型，使得它们能够服从人类的一些指示）</p>
<p>语言模型每次是给定一段东西，然后去预测下一个词，它是一个自监督模型，所以认为它是没有标号的。如果想让语言模型去解释某一个概念的话，就需要文本中出现过类似的东西，因此<strong>模型的行为取决于文本搜集的好坏</strong>。一般用来训练的文本大概都是几十亿、几百亿的词，所以具体里面有什么东西是不清楚的，只是大概知道文本质量的好坏，然后进行一定的清洗。因此模型的精细度是不够的，所以对整个模型的控制比较弱，一般就是大力出奇迹，把数据输入进去，得到什么样的模型就是什么</p>
<p>这样的问题在于：</p>
<ul>
<li><strong>有效性</strong>： 如果想让模型去做某个事情，但是模型始终学不会怎么办？因为文本中没有相应的东西。</li>
<li><strong>安全性</strong>： 模型输出一些不应该输出的东西怎么办？这对于大公司来讲将会造成很大的灾难</li>
</ul>
<p>最简单的办法就是<strong>标注一些数据</strong>，所以这篇文章的省流版本就是<strong>标注一点数据，然后将语言模型做一次微调，这样就能获得更好的效果</strong></p>
<ul>
<li>整个 OpenAI 或者说现在这些大的模型都是号称往无监督或者是自监督的方向发展，现在如果说还是需要进行数据标注，效果会很好，如果这么说的话，就是自相矛盾了，所以文章需要进行包装</li>
</ul>
<p><strong>Author</strong></p>
<p><img src="https://i0.hdslb.com/bfs/note/8c20b9e5f0b1d0c9421436130b7abb4779504209.png@1098w_!web-note.webp" alt=""></p>
<ul>
<li>作者基本上都是 OpenAI 的员工，带“ *”的是主要作者</li>
</ul>
<h1 id="2-摘要"><a href="#2-摘要" class="headerlink" title="2.摘要"></a>2.摘要</h1><p>把语言模型变大并不能代表它们会更好地按照用户的意图来做事情，大的语言模型很可能会生成一些<strong>不真实的</strong>、<strong>有害的</strong>或者是<strong>没有帮助</strong>的答案。换句话说，这些模型没有和用户站在一起（目标一致，达成合作）</p>
<ul>
<li>如果读者的关注点主要在研究上面，就可能会低估这一段话的重要性。因为在研究上，很多时候训练一个模型，在标准数据集上把整个分数刷上去就行了。但是在工业上的部署，也就是在 AI 模型的落地上面，<strong>安全性</strong>和<strong>有效性</strong>是非常重要的。</li>
<li>比如一个机器学习的产品，因为有一些地方没有做到位，从而引发争议导致整个产品下线，这种例子很多：</li>
<li>2015 年有用户反馈 Google 的照片服务将黑人的标签识别成了 Gorilla（大猩猩） ，导致 Google 紧急上线将 Gorilla 这个标签在模型中删掉。三年之后，Google photos 还是把 Gorilla 整个标签去掉了，也就是说，如果照片中有真的 Gorilla 的话，Google 是不会将它识别出来的；</li>
<li>2021 年纽约时报报道说 Facebook 因为它的 AI 算法把它的黑人视频加了一个灵长类动物的标签而道歉，跟之前的黑猩猩事件如出一辙；</li>
<li>微软发布的一个小冰聊天机器人的英文版在推特上发布 16 小时之后，用户发现它有一点<strong>种族歧视</strong>的语言，然后微软就紧急将它下架了，然后重新训练一个模型上线之后结果又乱讲话，最后导致整个产品被下线；</li>
<li>最近的例子，Meta 发布了一个叫做 Galactica 的模型（<a target="_blank" rel="noopener" href="https://galactica.org/explore/，由">https://galactica.org/explore/，由</a> paper with code 团队发布），它能够做很多学术相关的事情，比如讲一个公式翻译成一个语言来进行描述或者说将一段代码用数学公式写出来，以及解决数学题，在模型发布不久之后，就有人发现这个模型<strong>会生成一些错误的或者是有偏见的但是听上去很正确的东西</strong>，他认为这个是一个非常危险的事情，等于是在一本正经的胡说八道并且使别人相信了，这些批评导致模型在发布的三天之后，Meta 就将这个模型下架了。。。</li>
</ul>
<p>所以当将一个机器学习的模型部署到产品中的时候需要非常小心，需要特别注意它出错的地方，避免在公关上出现问题。通常对于简单的分类问题来说相对会好一点，只需要将标号中一些有争议性的标号拿掉，但是语言模型的输出<strong>特别灵活</strong></p>
<ul>
<li>一方面研究者享受这种灵活性带来的巨大的应用场景</li>
<li>另一方面，这种灵活性的输出，导致出错的概率会更大</li>
</ul>
<p>GPT-3 发布这么久，有出过什么事情吗？</p>
<ul>
<li>其实是有的，只是 OpenAI 作为一个创业公司，媒体对创业公司的容忍度相对来讲会高一些</li>
<li>但是如果是一些大厂，比如 Google 这样的大公司，把 GPT-3 这种模型做成一个产品的形式时，一旦出现什么问题，就会出现很大的公关问题</li>
<li>事实上，ChatGPT 已经在安全性上做了很多工作，避免去回答一些非法的问题，实际上大家早就找到了各种可能性来绕开这些限制。</li>
<li>其实有很多的可能性让ChatGPT发表一些不适当的言论，只是现在 OpenAI 的口碑比较良好，如果说换一个大厂将同样的模型发表出来，结果就不一样了</li>
</ul>
<p>这篇文章中<strong>展示了怎样对语言模型和人类的意图之间做 align</strong> ，具体使用的方法是<strong>使用人类的反馈进行微调（fine-tuning with human feedback）</strong></p>
<ul>
<li><strong>注意这里使用的是 human feedback，不是使用的带标签的数据</strong></li>
</ul>
<p>具体做法是写了很多的 <strong>prompt</strong> ，在** OpenAI 的 API 上收集到各种问题，然后用标注工具将这些问题的答案写出来，这样就标注了一个数据集，然后在这个数据集上对 GPT-3 的模型做微调**。</p>
<p>然后又收集了一个数据集，这个数据集就是对每个模型的输出（问它一个问题，它可能会输出很多模型，因为它是一个概率采样的问题）<strong>进行人工标注</strong>，标注出好坏的顺序，有了这个顺序之后，再用<strong>强化学习</strong>继续训练出一个模型，这个模型就叫做 <strong>InstructGPT</strong></p>
<p>所以作者主要做了<strong>两件事情</strong>：</p>
<ul>
<li>首先标注了一些数据，将问题和答案都写出来然后训练一个模型</li>
<li>接下来又做了一个排序的数据集，然后用强化学习再训练出一个模型</li>
</ul>
<p>因此一共有两个模型，结果证明在人类的评估上面， InstructGPT （有标号的数据集）1.3B 的模型参数要好过最大的 GPT-3，也就是175B，也就是说<strong>一个 1% 大小的模型的效果反而更好一点</strong>。另外 InstructGPT 能在真实性上更高地降低有害的答案出现的概率。在公开的 NLP 数据集上，它的性能也没有显著的下降。</p>
<p>因此，等价于是<strong>说 InstructGPT更小，但是效果更好</strong>，而且在一些别的公开数据集上性能也没有变差；当然，不得不承认的是 InstructGPT 还是会犯一些简单的错误。</p>
<p>整个摘要的核心思想是说，作者标记了一个数据集，然后在这个数据集上比 GPT-3 要小 100 倍的模型然后在上面做微调的效果比最大的 GPT-3 模型的效果可能还要好一些</p>
<ul>
<li>对于这个结果，也不是特别意外，因为标注的数据集信噪比更加好一点，所以学习起来更加简单一点，不需要那么大的模型</li>
<li><strong>transformer 模型就是对整个数据做压缩</strong>，把整个数据信息压缩进模型的参数，信噪比越高，而且标注的信息和最后要评估的数据集可能更近一点，所以就导致不需要压缩那么多的东西</li>
<li><strong>信噪比</strong>：方差即不确定性，不确定性即信息。也就是说对于一组样本来说，其方差越大，代表样本中含有的信息越多，所以可以将方差看作信息量的一个度量。因此，信噪比的统计学含义就是：能够被模型解释的信息与不能够被模型解释的信息之比。</li>
<li>虽然 OpenAI 和一些大的厂都是在说，训练一个特别大的模型，根本不需要标注，效果特别好，实际上在实用上来讲，如果这个方向一路走到底的时候，<strong>计算能力不一定能吃得消</strong>，而且数据可能增长到某个程度之后，可能覆盖的地方还是存在问题，而在那些想要的特性但是模型做不到的地方适当加入一些人类的标注，其实相对来讲更加划算</li>
</ul>
<p>所以一个好的方法需要平衡算力的需求和人类标注的代价</p>
<h1 id="2-导论"><a href="#2-导论" class="headerlink" title="2.导论"></a>2.导论</h1><p>导论就是摘要中所讲的故事的一个稍微详细的版本，首先讲问题，然后讲方法，最后讲结果</p>
<h2 id="2-1-存在的问题"><a href="#2-1-存在的问题" class="headerlink" title="2.1 存在的问题"></a>2.1 存在的问题</h2><p>大的语言模型能够<strong>通过提示的方式把任务作为输入</strong>，但是这些<strong>模型也经常会有一些不想要的行为</strong>，比如说捏造事实，生成有偏见的、有害的或者是没有按照想要的方式来，这是因为整个语言模型训练的目标函数有问题。</p>
<ul>
<li><strong>实际的目标函数</strong>：语言模型的目标函数是在网上的文本数据中预测下一个词，即给定一个文本中的一段话，然后预测这段话后面的词</li>
<li><strong>我们希望的目标函数</strong>：根据人的指示来生成安全的、有帮助的答案</li>
<li>两个目标函数其实是<strong>不一样的</strong>，所以作者把真正训练的目标函数和所想要让这个模型做的事情之间的差距叫做语言模型目标函数是没有 align。</li>
</ul>
<p>所以这篇文章的目的就是让语言模型更好一点：</p>
<ul>
<li>希望语言模型能够更有帮助性，能够解决想让它解决的事情</li>
<li>能够更加真诚，不要捏造事实，要实事求是</li>
<li>无害，既不要生成让人反感的输出，也不要生成一些可能对别人造成危害的输出</li>
</ul>
<h2 id="2-2-实现方法"><a href="#2-2-实现方法" class="headerlink" title="2.2 实现方法"></a>2.2 实现方法</h2><p><strong>基于人类反馈的强化学习</strong>（reinforcement learning from human feedback，<strong>RLHF</strong>）基于人类反馈的强化学习</p>
<p>图二（InstructGPT 怎样从 GPT-3 一步一步训练而来的，<strong>一共标注了两个标注数据集，生成了三个模型</strong>）</p>
<p><img src="https://i0.hdslb.com/bfs/note/c1e7ac722ae5e6cbad26981c57238a31b3ca17bf.png@1098w_!web-note.webp" alt=""></p>
<h3 id="Step-1：收集样本数据，有监督微调"><a href="#Step-1：收集样本数据，有监督微调" class="headerlink" title="Step 1：收集样本数据，有监督微调"></a>Step 1：收集样本数据，有监督微调</h3><ol>
<li>首先找了各种<strong>人来写各种各样的问题</strong>（这个问题在 GPT 中叫做 <strong>prompt</strong> ，具体来说就是向一个 6 岁的小孩解释什么是月亮；这些问题也可能是来自之前用户在向 GPT-3 提交的各种问题中筛选出来的）</li>
<li>然后<strong>继续让人写答案</strong>（比如说例子中问题的答案就是一些人去了月球。。。）</li>
<li>在有了问题和答案之后，就可以将这两个拼成一段话，然后<strong>在这个上面对 GPT-3 进行微调</strong></li>
</ol>
<p>因此，虽然这是人类标注的数据，但是在 GPT 眼中都是一样的，都是给定一段话然后预测下一个词，所以在微调上跟之前的在别的地方做微调或者是做预训练没有任何区别</p>
<p>GPT-3 的模型在人类标注的数据上微调出来的模型叫做 <strong>有监督的微调（supervised fine-tuning）</strong>，这是训练出来的第一个模型，其实训练出来的这个模型也能用，但是它的问题在于生成答案是一件很贵的事情，所以很难让人把所有各式各样的答案都写出来</p>
<h3 id="Step-2-收集排序数据，训练奖励模型"><a href="#Step-2-收集排序数据，训练奖励模型" class="headerlink" title="Step 2 : 收集排序数据，训练奖励模型"></a>Step 2 : 收集排序数据，训练奖励模型</h3><ol>
<li><strong>给定一个问题</strong>，让上一步训练好的预训练<strong>模型 SFT 生成答案</strong></li>
<li>GPT 每一次预测一个词的概率，可以根据这个概率采样出很多答案，通常来说可以用 beam search</li>
<li>这里生成了四个答案，然后把这<strong>四个答案的好坏进行人工标注，进行排序标注</strong></li>
<li>有了这些排序之后，再训练一个<strong>奖励模型（Reward Model，RM）</strong>，这个模型是说给定 prompt 得到输出，然后对这个输出生成一个分数，可以认为这个分数是一个奖励或者是打分，使得对答案的分数能够满足人工排序的关系（大小关系保持一致），一旦这个模型生成好之后，就能够对生成的答案进行打分</li>
</ol>
<h3 id="Step-3：使用RM模型优化SFT模型"><a href="#Step-3：使用RM模型优化SFT模型" class="headerlink" title="Step 3：使用RM模型优化SFT模型"></a>Step 3：使用RM模型优化SFT模型</h3><ol>
<li>继续微调之前训练好的 SFT模型，使得它生成的答案能够尽量得到一个比较高的分数，即每一次将它生成的答案放进 RM 中打分，然后优化 SFT 的参数使得它生成的答案在 RM 中获得更高的分数。</li>
</ol>
<p><strong>备注</strong>：两次对模型的微调：GPT3模型 → SFT模型 → RL模型，其实这里始终都是同一个模型，只是不同过程中名称不同。</p>
<ul>
<li><strong>需要SFT模型的原因</strong>： GPT3模型不一定能够保证根据人的指示、有帮助的、安全的生成答案需要人工标注数据进行微调。</li>
<li><strong>需要RM模型的原因</strong>：标注排序的判别式标注成本远远低于生成答案的生成式标注。</li>
<li><strong>需要RL模型的原因</strong>：在对SFT模型进行微调时生成的答案分布也会发生变化，会导致RM模型的评分会有偏差，需要用到强化学习.</li>
</ul>
<p>最后训练出来的模型就叫做 InstructGPT ，它是 GPT-3 经过以上三个步骤训练得来的。</p>
<p>从技术要点上来看，<strong>有以下几个技术</strong>：</p>
<ol>
<li>第一步中的数据标注的实现</li>
<li>第二步中的数据排序的实现</li>
<li>微调和 GPT-3 的微调是一样的</li>
<li>RM 模型的训练</li>
<li>有了 RM 模型之后，如何通过强化学习来训练</li>
</ol>
<h2 id="2-3-结果描述"><a href="#2-3-结果描述" class="headerlink" title="2.3 结果描述"></a>2.3 结果描述</h2><p>最后是关于结果的一些描述：</p>
<ol>
<li>标注人员觉得 InstructGPT 的答案要比 GPT-3 的答案明显要好很多；</li>
<li>InstructGPT 在真实性上要比 GPT-3 好一些；</li>
<li>InstructGPT 在生成有害的输出上要比 GPT-3 好一点，因为它可以说不想回答某一个问题，但是在偏见（比如性别歧视）上并没有太大的提升；</li>
<li>在做微调的时候通常是根据某一个目标做微调，可能会使得模型在一些别的任务上的性能会下降。作者的做法是在做强化学习的时候，将最原始的目标函数拿回来，使得虽然在做完微调之后在这种 QA 上面做的更好一点，但是在一些其他的任务，比如说公有的 NLP 数据集上也不至于说性能下降很多</li>
<li>虽然在整个过程中进行了人工标注，但是<strong>标注非常有主观性</strong>，因为是写一段文字或者是判断两段话的好坏，作者找了一些没有标注数据参与训练的标注人员，只是从结果的角度去评估 InstructGPT 的话他们还是觉得 InstructGPT 要比 GPT-3 好一些（人与人之间的喜好是有一定的相关性的）</li>
<li>作者将 GPT-3 在 InstructGPT 的数据和其他的公用数据集 FLAN 和 T0 上进行了微调，最后比较发现，还是在自己的数据上微调出来的效果会好一些，也就是说别人的数据可能和自己的数据在分布上不太一致，所以意味着<strong>微调对数据还是比较敏感的</strong>。</li>
<li>作者标注了大量的问题，但是因为语言模型比较灵活，不可能将所有的问题都标注出来，所以作者发现<strong>虽然标注的问题里面只有少部分是总结代码或者是问代码相关的问题</strong>，<strong>在训练完之后发现实际的模型在这方面的表现还是不错的</strong>，也就是说所训练出来的模型其实是有一些泛化性的，因此这也意味着其实也没有必要一定要将所有不同的问答类型全部标注，模型根据之前的先验知识<strong>具有一定的泛化性</strong>。</li>
<li>模型也还是<strong>会犯一些简单的错误</strong>，因为文中所展示的都是一些模型所表现出来的比较出乎意料的东西，但是可能在一些大家习以为常的地方很可能会出错，所以在这一点上可以认为 InstructGPT 或者说甚至现在的 ChatGPT 多多少少还是像一个玩具，而不是一个工具。<ul>
<li>工具不需要惊喜，但是需要保证可用性，不能在一些正常的地方出错</li>
</ul>
</li>
</ol>
<h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3.方法"></a>3.方法</h1><p>本文所使用的方法就是前面工作的方法，只是前面的工作主要用在文本样式的一致性和渐进式总结（类似于问答的场景下），方法本身没有本质上的区别（这些技术虽然都是 openAI 前面的研究，但是并不是 InstructGPT 的原创，这些技术之前就有了，只不过 InstructGPT 使用这些技术在一个新的数据集上重新训练了一下）</p>
<h2 id="3-1-Dataset"><a href="#3-1-Dataset" class="headerlink" title="3.1 Dataset"></a>3.1 <strong>Dataset</strong></h2><h3 id="（1）Prompt-数据集"><a href="#（1）Prompt-数据集" class="headerlink" title="（1）Prompt 数据集"></a>（1）Prompt 数据集</h3><p>首先<strong>标注人员写了很多的问题</strong>，这些问题包括：</p>
<ul>
<li><strong>Plain</strong>：让标注人员写任何的问题</li>
<li><strong>Few-shot</strong>：让标注人员写一个指令，有各种不同的指令，然后里面有后续的一些问题回答</li>
<li><strong>User-based</strong>：用户提供了一些想要支持的应用场景，然后将其构建成任务</li>
</ul>
<p>有了这些<strong>最初构建出来的 prompt 之后，作者训练了第一个 InstructGPT 模型</strong>，得到这个模型之后，将其放在 playground 中供大家使用。大家在使用的过程中可能又会提出一些问题，然后又把这些问题采集回来，并进行筛选。</p>
<ul>
<li>对每个用户最多采用 200 个问题</li>
<li>在划分训练集、验证集、测试集的时候是根据用户的 ID 来划分的（这个也很重要，当收集了很多来自不同用户的各种问题之后，不能把这些问题放在一起进行随机划分，因为一个用户可能会问一些类似的问题，如果这个问题同时出现在训练集和测试集中，就会造成数据污染，所以按照用户进行划分更加公平）</li>
<li>如果问题中包含了很多的用户信息，比如出现了人名，就将其过滤掉</li>
</ul>
<p>通过这个方法就<strong>得到了更多的 prompt</strong>。</p>
<h3 id="（2）三个模型的数据集"><a href="#（2）三个模型的数据集" class="headerlink" title="（2）三个模型的数据集"></a>（2）三个模型的数据集</h3><p>在有了这些 prompt 之后就产生了三个不同的数据集，数据集之间可能共享了一些问题：</p>
<ul>
<li><strong>SFT 数据集</strong>：让标注人员直接写答案。用来训练 SFT 模型的数据集中有 13000 个样本。</li>
<li><strong>RM 数据集</strong>：用来训练一个 RM 模型，只需要进行排序就可以了。用来训练 RM 模型的数据集中有 33000 个样本。</li>
<li><strong>PPO 数据集</strong>：用来训练强化模型，也就是 InstructGPT 。这个时候就不需要标注（标注来自于 RM 模型的标注）。用来训练 InstructGPT 模型的数据集中有 31000 个样本。</li>
</ul>
<h3 id="（3）一些数据集的例子"><a href="#（3）一些数据集的例子" class="headerlink" title="（3）一些数据集的例子"></a>（3）一些数据集的例子</h3><p>表 1 展示了 prompt 数据集中使用 API 的用户的用途分布情况，最多的是生成一些东西，其次是一些开放性的回答、头脑风暴等</p>
<p>表 2 中展示了一些例子</p>
<ul>
<li><strong>头脑风暴</strong>：列出五个能够使我保持对事业的热情的五个想法</li>
<li><strong>生成类</strong>：生成一个短故事</li>
<li><strong>重写</strong>：给定百老汇 show 的总结，将其中的要点列出来</li>
</ul>
<p><img src="image/image_Ft2wxlyP0i.png" alt=""></p>
<p>在文章的附录 A 中提供了大量的 prompt 的例子</p>
<p><img src="https://i0.hdslb.com/bfs/note/796218543084aaa9378b96b0aa3d1b9a5c143bec.png@1138w_!web-note.webp" alt=""></p>
<h2 id="3-2-数据标注"><a href="#3-2-数据标注" class="headerlink" title="3.2 数据标注"></a>3.2 数据标注</h2><p>作者在 Upwork（美国招聘合同工常用的网站） 和 ScaleAI（一个数据标注公司） 上招了一个 40 人组成的团队，在附录 B 中有对人员的筛选过程进行详细的描述</p>
<p>在标注的过程中，希望能够做到，尽量将帮助性排在第一位；在评测的时候尽量把真实性和无害性排在第一位。标注数据的时候给的指示和最终评估的时候不同。</p>
<p><strong>作者和标注人员紧密合作</strong>，因为整个任务相对来说还是比较开放的，而且比较难，所以需要不断地与标注人员进行沟通。</p>
<p>这些<strong>标注人员的一致性还是比较高</strong>的：72% 左右的情况下，大家是相互同意对方的一些评测。这就意味着这个任务可能具有二相性，但是大家的意向基本一致</p>
<p>如果之前没有做过<strong>数据标注</strong>，而且需要找人进行数据标注的话，可以参考作者所采用的方法，他的描述还是比较详细的</p>
<ul>
<li>特别是在附录中提供了很多的模板，又可能能够直接套用</li>
<li>作者还提供了标注网页的 UI 的样式，可以进行参考</li>
</ul>
<h2 id="3-3-模型"><a href="#3-3-模型" class="headerlink" title="3.3 模型"></a>3.3 模型</h2><p>总共有三个模型：</p>
<h3 id="（1）Supervised-fine-tuning（SFT）"><a href="#（1）Supervised-fine-tuning（SFT）" class="headerlink" title="（1）Supervised fine-tuning（SFT）"></a>（1）Supervised fine-tuning（<strong>SFT</strong>）</h3><p>等价于<strong>将 GPT-3 模型标注好的 prompt 和答案进行重新训练</strong>，总共训练了 16 个 epoch</p>
<p>因为数据比较少，总共只有 13000 个数据，所以 GPT 的模型训练一个 epoch 就过拟合了。这个模型也不是直接使用，而是<strong>用来初始化后面的模型</strong>，所以作者发现过拟合其实是没有问题的，对后面还能起到一定的帮助作用</p>
<h3 id="（2）Reward-Modeling（RM）"><a href="#（2）Reward-Modeling（RM）" class="headerlink" title="（2）Reward Modeling（RM）"></a>（2）Reward Modeling（<strong>RM</strong>）</h3><p>将 GPT-3 模型最后的 unembedding layer 去掉，在prompt和回复上面训练出来一个模型，并输出一个标量奖励。</p>
<ul>
<li>正常 GPT 进入最后一个输出层之后，放进 softmax 输出一个概率。现在 softmax 可以不用，在后面加上一个线性层来投影，即将所有词的输出投影到一个值上面，就是一个输出为 1 的线性层，就可以输出一个标量的分数。</li>
</ul>
<p>这里使用的是一个 6B 大小的RM，没有用最大的 175B</p>
<ul>
<li>作者发现 175B 大小的模型训练起来不是特别稳定（在比较大的模型训练，其实不稳定是它的一个比较大的痛点，而且现在也没有特别好的解决方案）。如果模型训练不稳定的话，在后面 RL 里面训练会比较麻烦</li>
<li>此外，用小一点的模型也能够节省算力</li>
</ul>
<p>因为输入的标注是排序，而不是让用户标注的值，仅仅是一个顺序，因此需要将这个顺序转换成一个值，作者使用的损失函数是排序中常见的 Pairwise-ranking loss：</p>
<script type="math/tex; mode=display">
\operatorname{loss}(\theta)=-\frac{1}{\left(\begin{array}{c}K \\ 2\end{array}\right)} E_{\left(x, y_{w}, y_{l}\right) \sim D}\left[\log \left(\sigma\left(r_{\theta}\left(x, y_{w}\right)-r_{\theta}\left(x, y_{l}\right)\right)\right)\right]</script><p><img src="image/image_8BKdsA8hoo.png" alt=""></p>
<p><strong>损失函数参数解释：</strong></p>
<ul>
<li>$D$：第二个数据集，人工对答案进行排序。</li>
<li>$x$：第二个数据集D中的问题，每个问题对应K个答案，答案的顺序已经人工标注好了。</li>
<li>$y_w$和$y_l$：x对应的K个答案中的两个，其中yw排序比yl高，因为是一对，所以叫pairwise。</li>
<li>$r_\theta(x,y)$：即需要训练的RM模型，对于输入的一对x和y得到的标量分数。</li>
<li>$\theta$：需要优化的参数。&#x20;</li>
</ul>
<p><strong>损失函数理解：</strong></p>
<ol>
<li>$x$和$y<em>w$这一对问题和答案，放进RM模型中算出一个分数$r</em>\theta(x,y_w)$</li>
<li>$x$和$y<em>l$这一对问题和答案，放进RM模型中算出一个分数$r</em>\theta(x,y_l)$</li>
<li>因为人工标注出$y<em>w$的排序要比$y_l$高，$r</em>\theta(x,y<em>w)$得到的分数应该比$r</em>\theta(x,y<em>l<br>)$得到的分数高，所以$r</em>\theta(x,y<em>w) - r</em>\theta(x,y_l)$这个差值要越大越好</li>
<li>把相减后的分数通过sigmoid，那么这个值就在-1到1之间，并且我们希望$\sigma(r<em>\theta(x,y_w) - r</em>\theta(x,y_l))$越大越好</li>
<li>这里相当于将排序问题转换为了分类问题，即$\sigma(r<em>\theta(x,y_w) - r</em>\theta(x,y_l))$越接近1，表示$y_w$比$y_l$排序高，属于1这个分类，反之属于-1这个分类。所以这里就用logistic loss，由于是二分类，也相当于是交叉熵损失函数。</li>
<li>对于每个问题有$K$个答案，所以前面除以$C(K,2)$，使得loss不会因为K的变化而变化太多。</li>
<li>最后是最小化$loss(\theta)$，就是要最大化$r<em>θ(x,y_w)-r</em>θ(x,y_l)$这个值，即如果一个答案的排序比另一个答案排序高的话，我们希望他们通过RM模型得到的分数之差能够越大越好。</li>
</ol>
<p><strong>对于K的选择，为什么选9，而不选择4？</strong></p>
<ol>
<li>进行标注的时候，需要花很多时间去理解问题，但答案和答案比较相近，所以4个答案排序要30秒，但9个答案排序可能40秒就够了。加上看问题的时间，K=9花的时间可能比K=4多了30%。同时C(9,2)=36，C(4,2)=6，即K=9生成的问答对是K=4的6倍，等于说K=9比K=4只多花了30%的时间，但是能够标注的信息量却是他的6倍，<strong>非常划算</strong>。</li>
<li>K=9时，每次计算loss都有36项$r_θ(x,y)$要计算，这个RM模型计算比较贵，但可以通过重复利用之前算过的值，使得只要计算9次就行，这样就<strong>可以剩下很多时间</strong>。</li>
</ol>
<p><strong>标注时为什么不选择只标注最好的那个，而是进行排序？</strong></p>
<ul>
<li>K=4 ，在标注的时候只标注最好的一个，也就是说从 4 个答案中选出最好的答案，在计算损失的时候就不是 pairwise ，因为没有两两比较信息 <strong>，将一个二分类的逻辑回归问题变成了一个多分类的 softmax</strong> ，等于是在从 4 个值里面选出最大的值</li>
<li>K=4的时候是在4个答案中只标注最好的那一个，标注方便很多，这时候计算loss时变成了一个多分类的softmax。但是这样做有一个问题，就是容易<strong>overfitting</strong>。所以K=9时，保留了排序的信息，从而解决overfitting的问题。&#x20;</li>
</ul>
<p>现在改成了全部答案的排序使得整个问题变得复杂一点：不是要学习得到一个分数然后选出最大的值，而是说要学一个分数使得整个 9 个答案的排序能够保留下来。所以标号变多了之后，发现过拟合就会好一些，这也是作者对之前的一些方法进行改动的原因</p>
<h3 id="（3）Reinforcement-learning（RL）"><a href="#（3）Reinforcement-learning（RL）" class="headerlink" title="（3）Reinforcement learning（RL）"></a>（3）Reinforcement learning（<strong>RL</strong>）</h3><p>这里用到的模型是强化学习中的 PPO ，</p>
<ul>
<li>强化学习中的算法有很多，PPO 是其中之一</li>
<li>使用 PPO 是因为 PPO 也是 OpenAI 之前的工作，PPO 的作者也在本文的作者之列，所以挑选了一个自己比较熟悉的</li>
</ul>
<p>PPO 模型简单来讲就是在下面的目标函数上进行随机梯度下降：</p>
<script type="math/tex; mode=display">
\begin{aligned} \operatorname{objective}(\phi)= & E_{(x, y) \sim D_{\pi_{\phi}^{\mathrm{RL}}}}\left[r_{\theta}(x, y)-\beta \log \left(\pi_{\phi}^{\mathrm{RL}}(y \mid x) / \pi^{\mathrm{SFT}}(y \mid x)\right)\right]+ \\ & \gamma E_{x \sim D_{\text {pretrain }}}\left[\log \left(\pi_{\phi}^{\mathrm{RL}}(x)\right)\right]\end{aligned}</script><p><img src="image/image_9EPjYcnizy.png" alt=""></p>
<p>这个目标函数和之前的主要区别是：<strong>数据分布是随着模型的更新变化的，在强化学习中称为环境会发生变化</strong></p>
<p><strong>参数解释：</strong></p>
<ul>
<li>$\pi^{SFT}$：SFT模型。之前在标好的问题和答案的数据上面用监督的微调训练出来的模型</li>
<li>$\pi<em>{\phi}^{\mathrm{RL}}$：强化学习中，模型叫做Policy，$\pi</em>{\phi}^{\mathrm{RL}}$就是需要调整的模型，即最终的模型。初始化是$\pi^{SFT}$。</li>
<li>$(x, y) \sim D<em>{\pi</em>{\phi}^{\mathrm{RL}}}$：x是第三个数据集中的问题，y是x通过$\pi_{\phi}^{\mathrm{RL}}$模型（当前模型）得到的答案。</li>
<li>$r_{\theta}(x, y)$：对问题x，答案y进行打分的RM模型。<strong>希望这个分数是最大的，优化这一项</strong>。</li>
<li>$\pi<em>{\phi}^{\mathrm{RL}}(y \mid x)$：问题x通过$\pi</em>{\phi}^{\mathrm{RL}}$得到答案y的概率，即对于每一个y的预测和它的softmax的输出相乘。</li>
<li>$\pi^{\mathrm{SFT}}(y \mid x)$：问题x通过$\pi^{\mathrm{SFT}}$得到答案y的概率。</li>
<li>$x∼D_{pretrain}$：x是来自GPT3预训练模型的数据。</li>
<li>$\beta$、$ \gamma<br>  $：调整系数。</li>
</ul>
<p><strong>目标函数理解：</strong> 优化目标是使得目标函数越大越好，$objective(\phi)$可分成三个部分，打分部分+KL散度部分+GPT3预训练部分</p>
<ol>
<li>将第三个数据集中的问题$x$，通过$\pi^{SFT}$模型得到答案$y$</li>
<li>把一对$(x,y)$送进RM模型进行打分，得到$r_{\theta}(x, y)$，即第一部分打分部分，这个分数越高就代表模型生成的答案越好</li>
<li>在每次更新参数后，$\pi<em>{\phi}^{\mathrm{RL}}$会发生变化，x通过$\pi</em>{\phi}^{\mathrm{RL}}$生成的y也会发生变化，而$r<em>{\theta}(x, y)$打分模型是根据$\pi^{SFT}$模型的数据训练而来，如果$\pi</em>{\phi}^{\mathrm{RL}}$和$\pi^{SFT}$差的太多，则会导致$r<em>{\theta}(x, y)$的分数估算不准确。因此需要通过<strong>KL散度</strong>来计算$\pi</em>{\phi}^{\mathrm{RL}}$生成的答案分布和$\pi^{SFT}$生成的答案分布之间的距离，使得两个模型之间不要差的太远。</li>
<li>我们希望两个模型的差距越小越好，即KL散度越小越好，前面需要加一个负号，使得$objective(\phi)$越大越好。这个就是KL散度部分。</li>
<li>如果没有第三项，那么模型最终可能只对这一个任务能够做好，在别的任务上会发生性能下降。所以第三部分就把原始的GPT3目标函数加了上去，使得前面两个部分在新的数据集上做拟合，同时保证原始的数据也不要丢，这个就是第三部分GPT3预训练部分。</li>
<li>当$\gamma=0$时，这个模型叫做PPO，当$\gamma$不为0时，这个模型叫做PPO-ptx。InstructGPT更偏向于使用PPO-ptx。</li>
<li>最终优化后的$\pi_{\phi}^{\mathrm{RL}}$模型就是InstructGPT的模型。&#x20;</li>
</ol>
<p>之前已经标好了数据，为了么要训练一个 $r_θ$ 之后再训练一个模型出来，为什么不直接训练？</p>
<ul>
<li>主要原因是<strong>标注的只是一个排序，而不是标注的答案</strong></li>
<li>给定一个模型，然后生成多个输出，由标注人员进行排序，再计算梯度，然后再对模型进行更新；下一次又生成新的数据，然后进行标注，这在 RL 中比较常见，叫做在线学习。如果想要做成在线学习的形式就需要实时对模型的生成结果进行排序，会造成人力或者是算力的浪费。所以在这个地方需要学习一个函数来替代掉这个人， $r_θ$  其实就是在学习人的排序从而给模型实时的反馈，这就是为什么这里需要训练两个模型。</li>
</ul>
<p>整个 RL 模型简单来说<strong>就是一个 PPO 的目标函数加上一个原始的 GPT-3 的目标函数结合在一起</strong>。可以看到它还是一个相对来讲比较简单的 RL 算法，其实比作者之前的工作还要简单一点</p>
<ul>
<li>在之前的工作中尝试在 RL 里面多走几个来回，现在只是在之前预训练好的模型之后，通过 RL 模型再跑一步，中间不需要人工进行数据标注</li>
<li>作者在实际操作过程中发现，这样对有一些任务有效果，但是对有些任务没有必要</li>
<li>对于一些比较复杂的任务，比如缩写任务，因为 y 的变化可能会比较大，所以重新进行标注可能会好一点</li>
<li>但相对来讲比较简单一点的任务，在 $r_\theta$ 变化没有那么大的情况下其实没有太大的必要</li>
</ul>
<h2 id="3-4小结"><a href="#3-4小结" class="headerlink" title="3.4小结"></a>3.4<strong>小结</strong></h2><p><img src="image/image_DoBbf7iBvy.png" alt=""></p>
<p>InstructGPT总共干了三件事情：</p>
<p>1、<strong>数据</strong>：将 prompt 和答案标出来，然后用最正常的 GPT 微调出一个模型</p>
<p>2、训练一个<strong>奖励模型</strong>去拟合人对模型中多个输出之间的排序，训练好之后将其放入到强化学习的框架</p>
<p>3、通过<strong>强化学习模型</strong>调整 SFT 模型，使得输出的结果在排序上更符合人的喜好</p>
<h1 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h1><p><img src="image/image_IC1H-53ElB.png" alt=""></p>
<ul>
<li>有三个不同大小的模型：原始的 GPT-3 ，1.3B~175B</li>
<li>y 轴表示和 175B 的 SFT 模型相比的胜率，正常的话是一半一半</li>
<li>GPT-3 在 prompt 上做比较多的调整，可以从图中看到有提升，但是跟有标注的比还是比较远的</li>
<li>实验结果也验证了导言中所说的用一个 1% 的模型，其实是能够打败 175B 的模型（是在一个特定的测试集上面，因为这个测试集和训练数据集是有一定的耦合性的）</li>
<li>在 GPT-3 这篇论文中也提到过，在没有看过任何训练数据的情况下，使用大力出奇迹的方式出来的模型，比用过训练数据的模型可能效果还要好一些，但也只是针对一些相对来讲比较简单的任务</li>
<li>在这篇文章中，整个任务是比较复杂的，prompt 比较长，而且答案也并不简单，在看过标注信息的前提下，提升还是比较大的</li>
</ul>
<h1 id="5-讨论"><a href="#5-讨论" class="headerlink" title="5.讨论"></a>5.讨论</h1><p>1、作者认为整个三个模型的训练的代价和预训练相比，相对来讲比较低</p>
<ul>
<li>因为<strong>样本比较少</strong>，就算是使用了 175B 的模型，样本数也足足小了几万倍或者几十万倍</li>
</ul>
<p>2、<strong>局限性</strong></p>
<ul>
<li>数据是由 40 个合同工标注出来的，这个模型的行为和这 40 个人是息息相关的，不一定能代表以后所有的用户，所以后续还需要招一些人或者是用户来提升模型的能力</li>
<li>比如这里面的数据主要是英语，所以在别的语言上肯定是有一定的差距的</li>
<li>在模型上面也不是完全安全，还是会出现各种问题</li>
</ul>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.<strong>总结</strong></h1><p>从技术上来讲，InstructGPT是一个比较<strong>实用</strong>的技术，它提供了一个方法：给定一个比较大的语言模型，怎样通过标注一些数据能迅速地提升它在某一个你所关心领域上的性能，使其能够达到一个实用的阶段</p>
<ul>
<li>这也给想<strong>用生成模型做产品</strong>提供了一个<strong>实际可操作</strong>的思路</li>
</ul>
<p>作者在一开始提到了三个目标：想要语言模型更加有<strong>帮助性</strong>，说更多的<strong>真话</strong>，以及<strong>无害性</strong></p>
<ul>
<li>实际上这篇文章主要还是在讲帮助性，也讲了整个数据标注的时候，也是优化帮助性</li>
<li>所以从<strong>创新性**</strong>和<strong>**完成度</strong>的角度，这篇文章一般，也为只是优化了一个相对来讲比较简单的目标，而没有同时考虑到剩下两个目标去显式地优化它们</li>
</ul>
<p>另外后面这个 <strong>RL 模型可能也是没有必要做的</strong></p>
<ul>
<li>可以选择在训练第一个模型的时候多标注一点数据，或者说可以用文本合成这样的方法来快速增大数据</li>
<li>这样做的好处就是在做微调的时候，直接将之前的代码拿过来用就可以了，而不需要去做 RL ，RL模型所带来的一系列复杂度的东西可以转移到数据上面，因为对数据进行处理相对来讲比较简单，那么整个模型的训练和部署就会变得更加简单</li>
<li>因此从<strong>实用性</strong>的角度来看，这样做的效果可能会更好一些</li>
</ul>
<p>所以其实就是显式地优化了帮助性这一个目标，使用了相对来讲比较复杂的 RL 算法也没有成功地说明使用它的<strong>必要性</strong>。</p>
<p>从一个创业公司的角度来讲，需要尽快地把产品做出来，效果做上去，其他的东西可能就没有那么重要，但是同样的做法，OpenAI 也许能做，但是别的公司不一定能做，在<strong>安全性</strong>上没有做太多完善的情况下，很有可能会引发公关危机。</p>
<h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7.其他"></a>7.其他</h1><h2 id="7-1-指示学习（Instruct-Learning）和提示（Prompt-Learning）学习"><a href="#7-1-指示学习（Instruct-Learning）和提示（Prompt-Learning）学习" class="headerlink" title="7.1 指示学习（Instruct Learning）和提示（Prompt Learning）学习"></a>7.1 指示学习（Instruct Learning）和提示（Prompt Learning）学习</h2><p>指示学习是谷歌Deepmind的Quoc V.Le团队在2021年的一篇名为《Finetuned Language Models Are Zero-Shot Learners》文章中提出的思想。指示学习和提示学习的目的都是去挖掘语言模型本身具备的知识。不同的是Prompt是激发语言模型的<strong>补全能力</strong>，例如根据上半句生成下半句，或是完形填空等。Instruct是激发语言模型的理解能力，它通过给出更明显的指令，让模型去做出正确的行动。我们可以通过下面的例子来理解这两个不同的学习方式：</p>
<ol>
<li><strong>提示学习</strong>：给女朋友买了这个项链，她很喜欢，这个项链太____了。</li>
<li><strong>指示学习</strong>：这句话的情感是非常正向的：给女朋友买了这个项链，她很喜欢。</li>
</ol>
<p>指示学习的优点是它经过多任务的微调后，也能够在其他任务上做zero-shot，而提示学习都是针对一个任务的。泛化能力不如指示学习。我们可以通过下图来理解微调，提示学习和指示学习。</p>
<p><img src="image/image_IkklR__48e.png" alt=""></p>
<h2 id="7-2-人类反馈的强化学习"><a href="#7-2-人类反馈的强化学习" class="headerlink" title="7.2 人类反馈的强化学习"></a>7.2 人类反馈的强化学习</h2><p>强化学习通过奖励（Reward）机制来指导模型训练，奖励机制可以看做传统模型训练机制的损失函数。奖励的计算要比损失函数更灵活和多样（AlphaGO的奖励是对局的胜负），这带来的代价是奖励的计算是不可导的，因此不能直接拿来做反向传播。强化学习的思路是通过对奖励的大量采样来拟合损失函数，从而实现模型的训练。同样人类反馈也是不可导的，那么我们也可以将人工反馈作为强化学习的奖励，基于人类反馈的强化学习便应运而生。</p>
<p>RLHF最早可以追溯到Google在2017年发表的《Deep Reinforcement Learning from Human Preferences》，它通过人工标注作为反馈，提升了强化学习在模拟机器人以及雅达利游戏上的表现效果。</p>
<p><img src="image/image_y36te5mFvs.png" alt=""></p>
<p>InstructGPT/ChatGPT中还用到了强化学习中一个经典的算法：OpenAI提出的最近策略优化（<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1707.06347.pdf" title="Proximal Policy Optimization，PPO">Proximal Policy Optimization，PPO</a>）。PPO算法是一种新型的Policy Gradient算法，Policy Gradient算法对步长十分敏感，但是又难以选择合适的步长，在训练过程中新旧策略的的变化差异如果过大则不利于学习。PPO提出了新的目标函数可以在多个训练步骤实现小批量的更新，解决了Policy Gradient算法中步长难以确定的问题。其实TRPO也是为了解决这个思想但是相比于TRPO算法PPO算法更容易求解。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://wdndev.github.io">Firefly</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://wdndev.github.io/paper_reading/2.6.InstructGPT/">https://wdndev.github.io/paper_reading/2.6.InstructGPT/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Transformer/">Transformer</a><a class="post-meta__tags" href="/tags/PaperReading/">PaperReading</a><a class="post-meta__tags" href="/tags/GPT/">GPT</a></div><div class="post_share"><div class="social-share" data-image="/img/wdn_icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/paper_reading/2.5.GPT_GPT-2_GPT-3/" title="论文精读 GPT、GPT-2、GPT-3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-01</div><div class="title">论文精读 GPT、GPT-2、GPT-3</div></div></a></div><div><a href="/paper_reading/2.7.GPT-4/" title="论文精读 GPT-4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-07</div><div class="title">论文精读 GPT-4</div></div></a></div><div><a href="/paper_reading/255.1.ChatGPT%20%E7%9B%B8%E5%85%B3%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95/" title="ChatGPT 相关核心算法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="title">ChatGPT 相关核心算法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#6-InstructGPT"><span class="toc-text">6.InstructGPT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0-%E5%89%8D%E8%A8%80ChatGPT"><span class="toc-text">0.前言ChatGPT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-ChatGPT-%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BA%94%E7%94%A8"><span class="toc-text">0.1 ChatGPT 的四个应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-2-ChatGPT-Methods"><span class="toc-text">0.2 ChatGPT Methods</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-3-InstructGPT"><span class="toc-text">0.3 InstructGPT</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A0%87%E9%A2%98%E3%80%81%E4%BD%9C%E8%80%85"><span class="toc-text">1.标题、作者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%91%98%E8%A6%81"><span class="toc-text">2.摘要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%AF%BC%E8%AE%BA"><span class="toc-text">2.导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">2.1 存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2.2 实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-1%EF%BC%9A%E6%94%B6%E9%9B%86%E6%A0%B7%E6%9C%AC%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9C%89%E7%9B%91%E7%9D%A3%E5%BE%AE%E8%B0%83"><span class="toc-text">Step 1：收集样本数据，有监督微调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-2-%E6%94%B6%E9%9B%86%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AE%AD%E7%BB%83%E5%A5%96%E5%8A%B1%E6%A8%A1%E5%9E%8B"><span class="toc-text">Step 2 : 收集排序数据，训练奖励模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-3%EF%BC%9A%E4%BD%BF%E7%94%A8RM%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96SFT%E6%A8%A1%E5%9E%8B"><span class="toc-text">Step 3：使用RM模型优化SFT模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%BB%93%E6%9E%9C%E6%8F%8F%E8%BF%B0"><span class="toc-text">2.3 结果描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95"><span class="toc-text">3.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Dataset"><span class="toc-text">3.1 Dataset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Prompt-%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-text">（1）Prompt 数据集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-text">（2）三个模型的数据集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">（3）一些数据集的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%95%B0%E6%8D%AE%E6%A0%87%E6%B3%A8"><span class="toc-text">3.2 数据标注</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.3 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Supervised-fine-tuning%EF%BC%88SFT%EF%BC%89"><span class="toc-text">（1）Supervised fine-tuning（SFT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89Reward-Modeling%EF%BC%88RM%EF%BC%89"><span class="toc-text">（2）Reward Modeling（RM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89Reinforcement-learning%EF%BC%88RL%EF%BC%89"><span class="toc-text">（3）Reinforcement learning（RL）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E5%B0%8F%E7%BB%93"><span class="toc-text">3.4小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%BB%93%E6%9E%9C"><span class="toc-text">4.结果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%AE%A8%E8%AE%BA"><span class="toc-text">5.讨论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93"><span class="toc-text">6.总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E5%85%B6%E4%BB%96"><span class="toc-text">7.其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E6%8C%87%E7%A4%BA%E5%AD%A6%E4%B9%A0%EF%BC%88Instruct-Learning%EF%BC%89%E5%92%8C%E6%8F%90%E7%A4%BA%EF%BC%88Prompt-Learning%EF%BC%89%E5%AD%A6%E4%B9%A0"><span class="toc-text">7.1 指示学习（Instruct Learning）和提示（Prompt Learning）学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E4%BA%BA%E7%B1%BB%E5%8F%8D%E9%A6%88%E7%9A%84%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0"><span class="toc-text">7.2 人类反馈的强化学习</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Firefly</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">簡</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'oe7vzWxH80qwJJjWslYTCViT-gzGzoHsz',
      appKey: 'k89nSbK0BTbmzmpQottRHvNI',
      avatar: 'monsterid',
      serverURLs: 'https://oe7vzwxh.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async src="/js/title.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":180,"height":360,"hOffset":0,"vOffset":-100},"mobile":{"show":true},"react":{"opacity":0.85},"log":false});</script></body></html>